"fix the use of wildcard expressions for data streams in update aliases api (#75526)          prior to this change, supplying a wildcard expression in the `indices` field     of an alias action would always result in a 404, despite data streams existing     that could match with the provided wildcard expression.          closes #75456","diff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/indexnameexpressionresolvertests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/indexnameexpressionresolvertests.javaCHAR(13)index 2d46154f5ab..20898fbd23a 100644CHAR(13)--- a/server/src/test/java/org/elasticsearch/cluster/metadata/indexnameexpressionresolvertests.javaCHAR(13)+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/indexnameexpressionresolvertests.javaCHAR(13)@@ -8,6 +8,7 @@CHAR(13) CHAR(13) package org.elasticsearch.cluster.metadata;CHAR(13) CHAR(13)+import org.apache.logging.log4j.level;CHAR(13) import org.elasticsearch.version;CHAR(13) import org.elasticsearch.action.docwriterequest;CHAR(13) import org.elasticsearch.action.indicesrequest;CHAR(13)@@ -24,6 +25,7 @@ import org.elasticsearch.cluster.metadata.indexmetadata.state;CHAR(13) import org.elasticsearch.common.strings;CHAR(13) import org.elasticsearch.common.settings.settings;CHAR(13) import org.elasticsearch.common.util.concurrent.threadcontext;CHAR(13)+import org.elasticsearch.core.tuple;CHAR(13) import org.elasticsearch.index.index;CHAR(13) import org.elasticsearch.index.indexnotfoundexception;CHAR(13) import org.elasticsearch.index.indexsettings;CHAR(13)@@ -31,29 +33,28 @@ import org.elasticsearch.indices.indexclosedexception;CHAR(13) import org.elasticsearch.indices.invalidindexnameexception;CHAR(13) import org.elasticsearch.indices.systemindexdescriptor;CHAR(13) import org.elasticsearch.indices.systemindexdescriptor.type;CHAR(13)+import org.elasticsearch.indices.systemindexdescriptorutils;CHAR(13) import org.elasticsearch.indices.systemindices;CHAR(13) import org.elasticsearch.indices.systemindices.feature;CHAR(13) import org.elasticsearch.indices.systemindices.systemindexaccesslevel;CHAR(13) import org.elasticsearch.indices.testindexnameexpressionresolver;CHAR(13) import org.elasticsearch.test.estestcase;CHAR(13)+import org.hamcrest.matcher;CHAR(13) CHAR(13) import java.time.instant;CHAR(13) import java.time.localdate;CHAR(13) import java.time.zoneoffset;CHAR(13) import java.util.arrays;CHAR(13) import java.util.collections;CHAR(13)-import java.util.comparator;CHAR(13) import java.util.enumset;CHAR(13) import java.util.hashset;CHAR(13) import java.util.list;CHAR(13)-import java.util.map;CHAR(13) import java.util.set;CHAR(13) import java.util.function.function;CHAR(13)-import java.util.stream.collectors;CHAR(13) CHAR(13) import static org.elasticsearch.cluster.metadata.datastreamtesthelper.backingindexequalto;CHAR(13) import static org.elasticsearch.cluster.metadata.datastreamtesthelper.createbackingindex;CHAR(13)-import static org.elasticsearch.cluster.metadata.datastreamtesthelper.createtimestampfield;CHAR(13)+import static org.elasticsearch.cluster.metadata.datastreamtesthelper.newinstance;CHAR(13) import static org.elasticsearch.cluster.metadata.indexmetadata.index_hidden_setting;CHAR(13) import static org.elasticsearch.common.util.set.sets.newhashset;CHAR(13) import static org.elasticsearch.indices.systemindices.external_system_index_access_control_header_key;CHAR(13)@@ -71,6 +72,8 @@ import static org.hamcrest.matchers.equalto;CHAR(13) import static org.hamcrest.matchers.is;CHAR(13) import static org.hamcrest.matchers.notnullvalue;CHAR(13) import static org.hamcrest.matchers.nullvalue;CHAR(13)+import static org.mockito.mockito.mock;CHAR(13)+import static org.mockito.mockito.when;CHAR(13) CHAR(13) public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)@@ -94,26 +97,30 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         epochmillis = randomlongbetween(1580536800000l, 1583042400000l);CHAR(13)     }CHAR(13) CHAR(13)-    public void testindexoptionsstrict() {CHAR(13)+    public void testconcreteindexnamesstrictexpand() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)+            .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indicesoptions[] indicesoptions = new indicesoptions[]{ indicesoptions.strictexpandopen(), indicesoptions.strictexpand()};CHAR(13)-        for (indicesoptions options : indicesoptions) {CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)+        for (indicesoptions options : list.of(indicesoptions.strictexpandopen(), indicesoptions.strictexpand())) {CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                randomfrom(systemindexaccesslevel.values())CHAR(13)+            );CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foo');CHAR(13)             assertequals(1, results.length);CHAR(13)             assertequals('foo', results[0]);CHAR(13) CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'bar'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'bar')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)             }CHAR(13) CHAR(13)@@ -122,18 +129,13 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertthat(results, arraycontaininginanyorder('foofoo', 'foobar'));CHAR(13) CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, 'foofoobar');CHAR(13)-            assertequals(new hashset<>(arrays.aslist('foo', 'foobar')),CHAR(13)-                         new hashset<>(arrays.aslist(results)));CHAR(13)-CHAR(13)-            {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'bar'));CHAR(13)-                assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)-            }CHAR(13)+            assertequals(new hashset<>(arrays.aslist('foo', 'foobar')), new hashset<>(arrays.aslist(results)));CHAR(13) CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'bar'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'bar')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)             }CHAR(13) CHAR(13)@@ -142,8 +144,10 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertthat(results, arraycontaininginanyorder('foofoo', 'foobar'));CHAR(13) CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'barbaz', 'bar'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'barbaz', 'bar')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)             }CHAR(13) CHAR(13)@@ -153,46 +157,35 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*');CHAR(13)             assertequals(1, results.length);CHAR(13)             assertequals('foo', results[0]);CHAR(13)-        }CHAR(13)-CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopen(), systemindexaccesslevel.none);CHAR(13)-        string[] results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(3, results.length);CHAR(13)-CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, (string[])null);CHAR(13)-        assertequals(3, results.length);CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.strictexpand(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(4, results.length);CHAR(13)-CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, (string[])null);CHAR(13)-        assertequals(4, results.length);CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)+            matcher<string[]> expectedresults = options == indicesoptions.strictexpandopen()CHAR(13)+                ? arraycontaininginanyorder('foo', 'foobar', 'foofoo')CHAR(13)+                : arraycontaininginanyorder('foo', 'foobar', 'foofoo', 'foofoo-closed');CHAR(13)+            assertthat(results, expectedresults);CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopen(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, 'foofoo*');CHAR(13)-        assertequals(3, results.length);CHAR(13)-        assertthat(results, arraycontaininginanyorder('foo', 'foobar', 'foofoo'));CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, (string[]) null);CHAR(13)+            assertthat(results, expectedresults);CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.strictexpand(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, 'foofoo*');CHAR(13)-        assertequals(4, results.length);CHAR(13)-        assertthat(results, arraycontaininginanyorder('foo', 'foobar', 'foofoo', 'foofoo-closed'));CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, 'foofoo*');CHAR(13)+            assertthat(results, expectedresults);CHAR(13)+        }CHAR(13)     }CHAR(13) CHAR(13)-    public void testindexoptionslenient() {CHAR(13)+    public void testconcreteindexnameslenientexpand() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)+            .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indicesoptions[] indicesoptions = new indicesoptions[]{indicesoptions.lenientexpandopen(), indicesoptions.lenientexpand()};CHAR(13)-        for (indicesoptions options : indicesoptions) {CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)+        for (indicesoptions options : list.of(indicesoptions.lenientexpandopen(), indicesoptions.lenientexpand())) {CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                randomfrom(systemindexaccesslevel.values())CHAR(13)+            );CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foo');CHAR(13)             assertequals(1, results.length);CHAR(13)             assertequals('foo', results[0]);CHAR(13)@@ -206,8 +199,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, 'foofoobar');CHAR(13)             assertequals(2, results.length);CHAR(13)-            assertequals(new hashset<>(arrays.aslist('foo', 'foobar')),CHAR(13)-                         new hashset<>(arrays.aslist(results)));CHAR(13)+            assertequals(new hashset<>(arrays.aslist('foo', 'foobar')), new hashset<>(arrays.aslist(results)));CHAR(13) CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, 'foo', 'bar');CHAR(13)             assertequals(1, results.length);CHAR(13)@@ -227,83 +219,82 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*');CHAR(13)             assertequals(1, results.length);CHAR(13)             assertequals('foo', results[0]);CHAR(13)-        }CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)-        string[] results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(3, results.length);CHAR(13)-CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.lenientexpand(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(arrays.tostring(results), 4, results.length);CHAR(13)+            matcher<string[]> expectedresults = options == indicesoptions.lenientexpandopen()CHAR(13)+                ? arraycontaininginanyorder('foo', 'foobar', 'foofoo')CHAR(13)+                : arraycontaininginanyorder('foo', 'foobar', 'foofoo', 'foofoo-closed');CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context,  'foofoo*');CHAR(13)-        assertequals(3, results.length);CHAR(13)-        assertthat(results, arraycontaininginanyorder('foo', 'foobar', 'foofoo'));CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)+            assertthat(results, expectedresults);CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.lenientexpand(), systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, 'foofoo*');CHAR(13)-        assertequals(4, results.length);CHAR(13)-        assertthat(results, arraycontaininginanyorder('foo', 'foobar', 'foofoo', 'foofoo-closed'));CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, 'foofoo*');CHAR(13)+            assertthat(results, expectedresults);CHAR(13)+        }CHAR(13)     }CHAR(13) CHAR(13)-    public void testindexoptionsallowunavailabledisallowempty() {CHAR(13)+    public void testconcreteindexnamesignoreunavailabledisallowempty() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo'))CHAR(13)-                .put(indexbuilder('foobar'))CHAR(13)-                .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)+            .put(indexbuilder('foo'))CHAR(13)+            .put(indexbuilder('foobar'))CHAR(13)+            .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         indicesoptions expandopen = indicesoptions.fromoptions(true, false, true, false);CHAR(13)         indicesoptions expand = indicesoptions.fromoptions(true, false, true, true);CHAR(13)-        indicesoptions[] indicesoptions = new indicesoptions[]{expandopen, expand};CHAR(13) CHAR(13)-        for (indicesoptions options : indicesoptions) {CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)+        for (indicesoptions options : list.of(expandopen, expand)) {CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                randomfrom(systemindexaccesslevel.values())CHAR(13)+            );CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foo');CHAR(13)             assertequals(1, results.length);CHAR(13)             assertequals('foo', results[0]);CHAR(13) CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'bar'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'bar')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)             }CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)             }CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)             }CHAR(13)-        }CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, expandopen, systemindexaccesslevel.none);CHAR(13)-        string[] results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(3, results.length);CHAR(13)+            matcher<string[]> expectedresults = options == expandopenCHAR(13)+                ? arraycontaininginanyorder('foo', 'foobar', 'foofoo')CHAR(13)+                : arraycontaininginanyorder('foo', 'foobar', 'foofoo', 'foofoo-closed');CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)+            assertthat(results, expectedresults);CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, expand, systemindexaccesslevel.none);CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)-        assertequals(4, results.length);CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)+            assertthat(results, expectedresults);CHAR(13)+        }CHAR(13)     }CHAR(13) CHAR(13)-    public void testindexoptionswildcardexpansion() {CHAR(13)+    public void testconcreteindexnamesexpandwildcards() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('bar'))CHAR(13)-                .put(indexbuilder('foobar').putalias(aliasmetadata.builder('barbaz')))CHAR(13)-                .put(indexbuilder('hidden', settings.builder().put('index.hidden', true).build()))CHAR(13)-                .put(indexbuilder('.hidden', settings.builder().put('index.hidden', true).build()))CHAR(13)-                .put(indexbuilder('.hidden-closed', settings.builder().put('index.hidden', true).build()).state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('hidden-closed', settings.builder().put('index.hidden', true).build()).state(indexmetadata.state.close));CHAR(13)+            .put(indexbuilder('foo').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('bar'))CHAR(13)+            .put(indexbuilder('foobar').putalias(aliasmetadata.builder('barbaz')))CHAR(13)+            .put(indexbuilder('hidden', settings.builder().put('index.hidden', true).build()))CHAR(13)+            .put(indexbuilder('.hidden', settings.builder().put('index.hidden', true).build()))CHAR(13)+            .put(indexbuilder('.hidden-closed', settings.builder().put('index.hidden', true).build()).state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('hidden-closed', settings.builder().put('index.hidden', true).build()).state(indexmetadata.state.close));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         // only closedCHAR(13)@@ -436,6 +427,14 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context, '-*');CHAR(13)         assertequals(0, results.length);CHAR(13) CHAR(13)+        options = indicesoptions.fromoptions(false, false, true, true, true);CHAR(13)+        indexnameexpressionresolver.context context2 = new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)+        indexnotfoundexception infe = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context2, '-*')CHAR(13)+        );CHAR(13)+        assertthat(infe.getresourceid().tostring(), equalto('[-*]'));CHAR(13)+CHAR(13)         // open and hiddenCHAR(13)         options = indicesoptions.fromoptions(false, true, true, false, true);CHAR(13)         context = new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)@@ -480,35 +479,33 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)         assertthat(results, emptyarray());CHAR(13) CHAR(13)-        results = indexnameexpressionresolver.concreteindexnames(context, 'h*');CHAR(13)-        assertthat(results, emptyarray());CHAR(13)+        indexnameexpressionresolver.context context3 = context;CHAR(13)+        infe = expectthrows(indexnotfoundexception.class, () -> indexnameexpressionresolver.concreteindexnames(context3, 'h*'));CHAR(13)+        assertthat(infe.getresourceid().tostring(), equalto('[h*]'));CHAR(13) CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context, 'hidden');CHAR(13)         assertthat(results, arraycontaininginanyorder('hidden'));CHAR(13) CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context, 'hidden-closed');CHAR(13)         assertthat(results, arraycontaininginanyorder('hidden-closed'));CHAR(13)-CHAR(13)-        options = indicesoptions.fromoptions(false, false, true, true, true);CHAR(13)-        indexnameexpressionresolver.context context2 = new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(context2, '-*'));CHAR(13)-        assertthat(infe.getresourceid().tostring(), equalto('[-*]'));CHAR(13)     }CHAR(13) CHAR(13)-    public void testindexoptionsnoexpandwildcards() {CHAR(13)+    public void testconcreteindexnamesnoexpandwildcards() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)+            .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        //ignore unavailable and allow no indicesCHAR(13)+        // ignore unavailable and allow no indicesCHAR(13)         {CHAR(13)             indicesoptions noexpandlenient = indicesoptions.fromoptions(true, true, false, false, randomboolean());CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, noexpandlenient, systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                noexpandlenient,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'baz*');CHAR(13)             assertthat(results, emptyarray());CHAR(13) CHAR(13)@@ -520,22 +517,27 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertequals(2, results.length);CHAR(13)             assertthat(results, arraycontaininginanyorder('foo', 'foobar'));CHAR(13) CHAR(13)-            results = indexnameexpressionresolver.concreteindexnames(context, (string[])null);CHAR(13)+            results = indexnameexpressionresolver.concreteindexnames(context, (string[]) null);CHAR(13)             assertequals(0, results.length);CHAR(13) CHAR(13)             results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)             assertequals(0, results.length);CHAR(13)         }CHAR(13) CHAR(13)-        //ignore unavailable but don't allow no indicesCHAR(13)+        // ignore unavailable but don't allow no indicesCHAR(13)         {CHAR(13)             indicesoptions noexpanddisallowempty = indicesoptions.fromoptions(true, false, false, false, randomboolean());CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, noexpanddisallowempty, systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                noexpanddisallowempty,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13) CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)             }CHAR(13) CHAR(13)@@ -548,29 +550,39 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertthat(results, arraycontaininginanyorder('foo', 'foobar'));CHAR(13) CHAR(13)             {CHAR(13)-                //unavailable indices are ignored but no indices are disallowedCHAR(13)+                // unavailable indices are ignored but no indices are disallowedCHAR(13)                 expectthrows(indexnotfoundexception.class, () -> indexnameexpressionresolver.concreteindexnames(context, 'bar', 'baz'));CHAR(13)             }CHAR(13)         }CHAR(13) CHAR(13)-        //error on unavailable but allow no indicesCHAR(13)+        // error on unavailable but allow no indicesCHAR(13)         {CHAR(13)             indicesoptions noexpanderrorunavailable = indicesoptions.fromoptions(false, true, false, false, randomboolean());CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, noexpanderrorunavailable, systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                noexpanderrorunavailable,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)             {CHAR(13)-                string[] results = indexnameexpressionresolver.concreteindexnames(context, 'baz*');CHAR(13)-                assertthat(results, emptyarray());CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*')CHAR(13)+                );CHAR(13)+                assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)             }CHAR(13)             {CHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*'));CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)             }CHAR(13)             {CHAR(13)-                //unavailable indices are not ignored, hence the error on the first unavailable indices encounteredCHAR(13)-                indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                        () -> indexnameexpressionresolver.concreteindexnames(context, 'bar', 'baz'));CHAR(13)+                // unavailable indices are not ignored, hence the error on the first unavailable indices encounteredCHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.concreteindexnames(context, 'bar', 'baz')CHAR(13)+                );CHAR(13)                 assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)             }CHAR(13)             {CHAR(13)@@ -580,17 +592,24 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             }CHAR(13)         }CHAR(13) CHAR(13)-        //error on both unavailable and no indicesCHAR(13)+        // error on both unavailable and no indicesCHAR(13)         {CHAR(13)             indicesoptions noexpandstrict = indicesoptions.fromoptions(false, false, false, false, randomboolean());CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, noexpandstrict, systemindexaccesslevel.none);CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                noexpandstrict,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*')CHAR(13)+            );CHAR(13)             assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13) CHAR(13)-            indexnotfoundexception infe2 = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*'));CHAR(13)+            indexnotfoundexception infe2 = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*')CHAR(13)+            );CHAR(13)             assertthat(infe2.getindex().getname(), equalto('baz*'));CHAR(13) CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foofoobar');CHAR(13)@@ -601,57 +620,85 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)     public void testindexoptionssingleindexnoexpandwildcards() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)-                .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)-                .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)+            .put(indexbuilder('foo').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foobar').putalias(aliasmetadata.builder('foofoobar')))CHAR(13)+            .put(indexbuilder('foofoo-closed').state(indexmetadata.state.close))CHAR(13)+            .put(indexbuilder('foofoo').putalias(aliasmetadata.builder('barbaz')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        //error on both unavailable and no indices + every alias needs to expand to a single indexCHAR(13)+        // error on both unavailable and no indices + every alias needs to expand to a single indexCHAR(13) CHAR(13)         {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'baz*')CHAR(13)+            );CHAR(13)             assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'baz*')CHAR(13)+            );CHAR(13)             assertthat(infe.getindex().getname(), equalto('baz*'));CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)-            illegalargumentexception e = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foofoobar'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            illegalargumentexception e = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foofoobar')CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), containsstring('alias [foofoobar] has more than one index associated with it'));CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)-            illegalargumentexception e = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'foofoobar'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            illegalargumentexception e = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foo', 'foofoobar')CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), containsstring('alias [foofoobar] has more than one index associated with it'));CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)-            indexclosedexception ince = expectthrows(indexclosedexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foofoo-closed', 'foofoobar'));CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            indexclosedexception ince = expectthrows(CHAR(13)+                indexclosedexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foofoo-closed', 'foofoobar')CHAR(13)+            );CHAR(13)             assertthat(ince.getmessage(), equalto('closed'));CHAR(13)             assertequals(ince.getindex().getname(), 'foofoo-closed');CHAR(13)         }CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-            indicesoptions.strictsingleindexnoexpandforbidclosed(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foo', 'barbaz');CHAR(13)         assertequals(2, results.length);CHAR(13)         assertthat(results, arraycontaininginanyorder('foo', 'foofoo'));CHAR(13)@@ -661,14 +708,19 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(metadata.builder().build()).build();CHAR(13) CHAR(13)         indicesoptions options = indicesoptions.strictexpandopen();CHAR(13)-        final indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, options, systemindexaccesslevel.none);CHAR(13)+        final indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            options,CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         string[] results = indexnameexpressionresolver.concreteindexnames(context, strings.empty_array);CHAR(13)         assertthat(results, emptyarray());CHAR(13) CHAR(13)         {CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo'));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foo')CHAR(13)+            );CHAR(13)             assertthat(infe.getindex().getname(), equalto('foo'));CHAR(13)         }CHAR(13) CHAR(13)@@ -676,14 +728,18 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertthat(results, emptyarray());CHAR(13) CHAR(13)         {CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(context, 'foo*', 'bar'));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'foo*', 'bar')CHAR(13)+            );CHAR(13)             assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)         }CHAR(13) CHAR(13)-CHAR(13)-        final indexnameexpressionresolver.context context2 =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)+        final indexnameexpressionresolver.context context2 = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context2, strings.empty_array);CHAR(13)         assertthat(results, emptyarray());CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context2, 'foo');CHAR(13)@@ -693,177 +749,297 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context2, 'foo*', 'bar');CHAR(13)         assertthat(results, emptyarray());CHAR(13) CHAR(13)-        final indexnameexpressionresolver.context context3 =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true, false, true, false),CHAR(13)-                systemindexaccesslevel.none);CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(context3, strings.empty_array));CHAR(13)-        assertthat(infe.getresourceid().tostring(), equalto('[_all]'));CHAR(13)-    }CHAR(13)-CHAR(13)-    public static indexmetadata.builder indexbuilder(string index) {CHAR(13)-        return indexbuilder(index, settings.empty);CHAR(13)-    }CHAR(13)-CHAR(13)-    private static indexmetadata.builder indexbuilder(string index, settings additionalsettings) {CHAR(13)-        return indexmetadata.builder(index).settings(settings(additionalsettings));CHAR(13)-    }CHAR(13)+        final indexnameexpressionresolver.context context3 = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, false, true, false),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        {CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context3, strings.empty_array)CHAR(13)+            );CHAR(13)+            assertthat(infe.getresourceid().tostring(), equalto('[_all]'));CHAR(13)+        }CHAR(13) CHAR(13)-    private static settings.builder settings(settings additionalsettings) {CHAR(13)-        return settings(version.current).put(indexmetadata.setting_number_of_shards, 1)CHAR(13)-            .put(indexmetadata.setting_number_of_replicas, 0)CHAR(13)-            .put(additionalsettings);CHAR(13)+        // no wildcard expandCHAR(13)+        final indexnameexpressionresolver.context context4 = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(false, true, false, false),CHAR(13)+            randomfrom(systemindexaccesslevel.values())CHAR(13)+        );CHAR(13)+        results = indexnameexpressionresolver.concreteindexnames(context4, strings.empty_array);CHAR(13)+        assertthat(results, emptyarray());CHAR(13)+        {CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context4, 'foo')CHAR(13)+            );CHAR(13)+            assertthat(infe.getindex().getname(), equalto('foo'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context4, 'foo*')CHAR(13)+            );CHAR(13)+            assertthat(infe.getindex().getname(), equalto('foo*'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context4, 'bar', 'foo*')CHAR(13)+            );CHAR(13)+            assertthat(infe.getindex().getname(), equalto('bar'));CHAR(13)+        }CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindicesignoreindicesonemissingindex() {CHAR(13)-        metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx'))CHAR(13)-                .put(indexbuilder('kuku'));CHAR(13)+        metadata.builder mdbuilder = metadata.builder().put(indexbuilder('testxxx')).put(indexbuilder('kuku'));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopen(), systemindexaccesslevel.none);CHAR(13)-CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(context, 'testzzz'));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.strictexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        indexnotfoundexception infe = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context, 'testzzz')CHAR(13)+        );CHAR(13)         assertthat(infe.getmessage(), is('no such index [testzzz]'));CHAR(13)+        // same as above, but do not expand wildcardsCHAR(13)+        indexnameexpressionresolver.context context_no_expand = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            ),CHAR(13)+            randomfrom(systemindexaccesslevel.values())CHAR(13)+        );CHAR(13)+        indexnotfoundexception infe_no_expand = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context_no_expand, 'testzzz')CHAR(13)+        );CHAR(13)+        assertthat(infe_no_expand.getmessage(), is('no such index [testzzz]'));CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindicesignoreindicesonemissingindexotherfound() {CHAR(13)-        metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx'))CHAR(13)-                .put(indexbuilder('kuku'));CHAR(13)+        metadata.builder mdbuilder = metadata.builder().put(indexbuilder('testxxx')).put(indexbuilder('kuku'));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxx', 'testzzz')),CHAR(13)-            equalto(newhashset('testxxx')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxx', 'testzzz')),CHAR(13)+            equalto(newhashset('testxxx'))CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindicesignoreindicesallmissing() {CHAR(13)-        metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx'))CHAR(13)-                .put(indexbuilder('kuku'));CHAR(13)+        metadata.builder mdbuilder = metadata.builder().put(indexbuilder('testxxx')).put(indexbuilder('kuku'));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopen(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.strictexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13) CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(context, 'testmo', 'testmahdy'));CHAR(13)+        indexnotfoundexception infe = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context, 'testmo', 'testmahdy')CHAR(13)+        );CHAR(13)         assertthat(infe.getmessage(), is('no such index [testmo]'));CHAR(13)+        // same as above, but do not expand wildcardsCHAR(13)+        indexnameexpressionresolver.context context_no_expand = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            ),CHAR(13)+            randomfrom(systemindexaccesslevel.values())CHAR(13)+        );CHAR(13)+        indexnotfoundexception infe_no_expand = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context_no_expand, 'testmo', 'testmahdy')CHAR(13)+        );CHAR(13)+        assertthat(infe_no_expand.getmessage(), is('no such index [testmo]'));CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindicesignoreindicesemptyrequest() {CHAR(13)-        metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx'))CHAR(13)-                .put(indexbuilder('kuku'));CHAR(13)+        metadata.builder mdbuilder = metadata.builder().put(indexbuilder('testxxx')).put(indexbuilder('kuku'));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, new string[]{})),CHAR(13)-            equalto(newhashset('kuku', 'testxxx')));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, new string[] {})),CHAR(13)+            equalto(newhashset('kuku', 'testxxx'))CHAR(13)+        );CHAR(13)     }CHAR(13)+CHAR(13)     public void testconcreteindicesnoindiceserrormessage() {CHAR(13)         metadata.builder mdbuilder = metadata.builder();CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-            indicesoptions.fromoptions(false, false, true, true), systemindexaccesslevel.none);CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(context, new string[]{}));CHAR(13)-        assertthat(infe.getmessage(), is('no such index [null] and no indices exist'));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(false, false, true, true),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        indexnotfoundexception infe = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindices(context, new string[] {})CHAR(13)+        );CHAR(13)+        assertthat(infe.getmessage(), is('no such index [_all] and no indices exist'));CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindicesnoindiceserrormessagenoexpand() {CHAR(13)         metadata.builder mdbuilder = metadata.builder();CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-            indicesoptions.fromoptions(false, false, false, false), systemindexaccesslevel.none);CHAR(13)-        indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(context, new string[]{}));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(false, false, false, false),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        indexnotfoundexception infe = expectthrows(CHAR(13)+            indexnotfoundexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindices(context, new string[] {})CHAR(13)+        );CHAR(13)         assertthat(infe.getmessage(), is('no such index [_all] and no indices exist'));CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindiceswildcardexpansion() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx').state(state.open))CHAR(13)-                .put(indexbuilder('testxxy').state(state.open))CHAR(13)-                .put(indexbuilder('testxyy').state(state.close))CHAR(13)-                .put(indexbuilder('testyyy').state(state.open))CHAR(13)-                .put(indexbuilder('testyyx').state(state.open));CHAR(13)+            .put(indexbuilder('testxxx').state(state.open))CHAR(13)+            .put(indexbuilder('testxxy').state(state.open))CHAR(13)+            .put(indexbuilder('testxyy').state(state.close))CHAR(13)+            .put(indexbuilder('testyyy').state(state.open))CHAR(13)+            .put(indexbuilder('testyyx').state(state.open));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true, true, false, false),CHAR(13)-                systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)-            equalto(new hashset<string>()));CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true, true, true, false),CHAR(13)-            systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)-            equalto(newhashset('testxxx', 'testxxy')));CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true, true, false, true),CHAR(13)-            systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)-            equalto(newhashset('testxyy')));CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true, true, true, true),CHAR(13)-            systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)-            equalto(newhashset('testxxx', 'testxxy', 'testxyy')));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, true, false, false),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')), equalto(new hashset<string>()));CHAR(13)+        context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, true, true, false),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)+            equalto(newhashset('testxxx', 'testxxy'))CHAR(13)+        );CHAR(13)+        context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, true, false, true),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')), equalto(newhashset('testxyy')));CHAR(13)+        context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, true, true, true),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)+            equalto(newhashset('testxxx', 'testxxy', 'testxyy'))CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)     public void testconcreteindiceswildcardwithnegation() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('testxxx').state(state.open))CHAR(13)-                .put(indexbuilder('testxxy').state(state.open))CHAR(13)-                .put(indexbuilder('testxyy').state(state.open))CHAR(13)-                .put(indexbuilder('-testxyz').state(state.open))CHAR(13)-                .put(indexbuilder('-testxzz').state(state.open))CHAR(13)-                .put(indexbuilder('-testyyy').state(state.open))CHAR(13)-                .put(indexbuilder('testyyy').state(state.open))CHAR(13)-                .put(indexbuilder('testyyx').state(state.open));CHAR(13)+            .put(indexbuilder('testxxx').state(state.open))CHAR(13)+            .put(indexbuilder('testxxy').state(state.open))CHAR(13)+            .put(indexbuilder('testxyy').state(state.open))CHAR(13)+            .put(indexbuilder('-testxyz').state(state.open))CHAR(13)+            .put(indexbuilder('-testxzz').state(state.open))CHAR(13)+            .put(indexbuilder('-testyyy').state(state.open))CHAR(13)+            .put(indexbuilder('testyyy').state(state.open))CHAR(13)+            .put(indexbuilder('testyyx').state(state.open));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                indicesoptions.fromoptions(true, true, true, true), systemindexaccesslevel.none);CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)-                equalto(newhashset('testxxx', 'testxxy', 'testxyy')));CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(true, true, true, true),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testx*')),CHAR(13)+            equalto(newhashset('testxxx', 'testxxy', 'testxyy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'test*', '-testx*')),CHAR(13)-                equalto(newhashset('testyyy', 'testyyx')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'test*', '-testx*')),CHAR(13)+            equalto(newhashset('testyyy', 'testyyx'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testx*')),CHAR(13)-                equalto(newhashset('-testxyz', '-testxzz')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testx*')),CHAR(13)+            equalto(newhashset('-testxyz', '-testxzz'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxy', '-testx*')),CHAR(13)-                equalto(newhashset('testxxy', '-testxyz', '-testxzz')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxy', '-testx*')),CHAR(13)+            equalto(newhashset('testxxy', '-testxyz', '-testxzz'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, '*', '--testx*')),CHAR(13)-                equalto(newhashset('testxxx', 'testxxy', 'testxyy', 'testyyx', 'testyyy', '-testyyy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, '*', '--testx*')),CHAR(13)+            equalto(newhashset('testxxx', 'testxxy', 'testxyy', 'testyyx', 'testyyy', '-testyyy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testxxx', 'test*')),CHAR(13)-                equalto(newhashset('testyyx', 'testxxx', 'testxyy', 'testyyy', 'testxxy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testxxx', 'test*')),CHAR(13)+            equalto(newhashset('testyyx', 'testxxx', 'testxyy', 'testyyy', 'testxxy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'test*', '-testxxx')),CHAR(13)-                equalto(newhashset('testyyx', 'testxyy', 'testyyy', 'testxxy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'test*', '-testxxx')),CHAR(13)+            equalto(newhashset('testyyx', 'testxyy', 'testyyy', 'testxxy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxx', 'testxxy', 'testyyy', '-testyyy')),CHAR(13)-                equalto(newhashset('testxxx', 'testxxy', 'testyyy', '-testyyy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testxxx', 'testxxy', 'testyyy', '-testyyy')),CHAR(13)+            equalto(newhashset('testxxx', 'testxxy', 'testyyy', '-testyyy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testyyy', 'testyyx', 'testx*', '-testxxx')),CHAR(13)-                equalto(newhashset('testyyy', 'testyyx', 'testxxy', 'testxyy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, 'testyyy', 'testyyx', 'testx*', '-testxxx')),CHAR(13)+            equalto(newhashset('testyyy', 'testyyx', 'testxxy', 'testxyy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testxxx', '*testy*', '-testyyy')),CHAR(13)-                equalto(newhashset('testyyx', 'testyyy', '-testyyy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(context, '-testxxx', '*testy*', '-testyyy')),CHAR(13)+            equalto(newhashset('testyyx', '-testyyy'))CHAR(13)+        );CHAR(13) CHAR(13)         string[] indexnames = indexnameexpressionresolver.concreteindexnames(state, indicesoptions.lenientexpandopen(), '-doesnotexist');CHAR(13)         assertequals(0, indexnames.length);CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(state, indicesoptions.lenientexpandopen(), '-*')),CHAR(13)-                equalto(newhashset('-testxyz', '-testxzz', '-testyyy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(indexnameexpressionresolver.concreteindexnames(state, indicesoptions.lenientexpandopen(), '-*')),CHAR(13)+            equalto(newhashset('-testxyz', '-testxzz', '-testyyy'))CHAR(13)+        );CHAR(13) CHAR(13)-        assertthat(newhashset(indexnameexpressionresolver.concreteindexnames(state, indicesoptions.lenientexpandopen(),CHAR(13)-                                'testxxx', 'testxxy', 'testxyy', '-testxxy')),CHAR(13)-                equalto(newhashset('testxxx', 'testxyy', 'testxxy')));CHAR(13)+        assertthat(CHAR(13)+            newhashset(CHAR(13)+                indexnameexpressionresolver.concreteindexnames(CHAR(13)+                    state,CHAR(13)+                    indicesoptions.lenientexpandopen(),CHAR(13)+                    'testxxx',CHAR(13)+                    'testxxy',CHAR(13)+                    'testxyy',CHAR(13)+                    '-testxxy'CHAR(13)+                )CHAR(13)+            ),CHAR(13)+            equalto(newhashset('testxxx', 'testxyy', 'testxxy'))CHAR(13)+        );CHAR(13) CHAR(13)         indexnames = indexnameexpressionresolver.concreteindexnames(state, indicesoptions.lenientexpandopen(), '*', '-*');CHAR(13)         assertequals(0, indexnames.length);CHAR(13)@@ -871,13 +1047,13 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)     public void testconcreteindiceswildcardandaliases() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo_foo').state(state.open).putalias(aliasmetadata.builder('foo')))CHAR(13)-                .put(indexbuilder('bar_bar').state(state.open).putalias(aliasmetadata.builder('foo')));CHAR(13)+            .put(indexbuilder('foo_foo').state(state.open).putalias(aliasmetadata.builder('foo')))CHAR(13)+            .put(indexbuilder('bar_bar').state(state.open).putalias(aliasmetadata.builder('foo')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         // when ignorealiases option is set, concreteindexnames resolves the provided expressionsCHAR(13)         // only against the defined indicesCHAR(13)-        indicesoptions ignorealiasesoptions = indicesoptions.fromoptions(false, false, true, false, true, false, true, false);CHAR(13)+        indicesoptions ignorealiasesoptions = indicesoptions.fromoptions(false, randomboolean(), true, false, true, false, true, false);CHAR(13) CHAR(13)         string[] indexnamesindexwildcard = indexnameexpressionresolver.concreteindexnames(state, ignorealiasesoptions, 'foo*');CHAR(13) CHAR(13)@@ -894,14 +1070,41 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertequals(1, indexnamesindexwildcard.length);CHAR(13)         assertequals('foo_foo', indexnamesindexwildcard[0]);CHAR(13) CHAR(13)-        illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(state, ignorealiasesoptions, 'foo'));CHAR(13)-        assertequals('the provided expression [foo] matches an alias, specify the corresponding concrete indices instead.',CHAR(13)-                iae.getmessage());CHAR(13)+        illegalargumentexception iae = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(state, ignorealiasesoptions, 'foo')CHAR(13)+        );CHAR(13)+        assertequals(CHAR(13)+            'the provided expression [foo] matches an alias, specify the corresponding concrete indices instead.',CHAR(13)+            iae.getmessage()CHAR(13)+        );CHAR(13)+CHAR(13)+        // same as above, but do not expand wildcardsCHAR(13)+        iae = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(CHAR(13)+                state,CHAR(13)+                indicesoptions.fromoptions(false, randomboolean(), false, false, true, false, true, false),CHAR(13)+                'foo'CHAR(13)+            )CHAR(13)+        );CHAR(13)+        assertequals(CHAR(13)+            'the provided expression [foo] matches an alias, specify the corresponding concrete indices instead.',CHAR(13)+            iae.getmessage()CHAR(13)+        );CHAR(13) CHAR(13)         // when ignorealiases option is not set, concreteindexnames resolves the providedCHAR(13)         // expressions against the defined indices and aliasesCHAR(13)-        indicesoptions indicesandaliasesoptions = indicesoptions.fromoptions(false, false, true, false, true, false, false, false);CHAR(13)+        indicesoptions indicesandaliasesoptions = indicesoptions.fromoptions(CHAR(13)+            false,CHAR(13)+            randomboolean(),CHAR(13)+            true,CHAR(13)+            false,CHAR(13)+            true,CHAR(13)+            false,CHAR(13)+            false,CHAR(13)+            falseCHAR(13)+        );CHAR(13) CHAR(13)         list<string> indexnames = arrays.aslist(indexnameexpressionresolver.concreteindexnames(state, indicesandaliasesoptions, 'foo*'));CHAR(13)         assertequals(2, indexnames.size());CHAR(13)@@ -922,6 +1125,13 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertequals(2, indexnames.size());CHAR(13)         asserttrue(indexnames.contains('foo_foo'));CHAR(13)         asserttrue(indexnames.contains('bar_bar'));CHAR(13)+CHAR(13)+        // same as above, but do not expand wildcardsCHAR(13)+        indicesandaliasesoptions = indicesoptions.fromoptions(false, randomboolean(), false, false, true, false, false, false);CHAR(13)+        indexnames = arrays.aslist(indexnameexpressionresolver.concreteindexnames(state, indicesandaliasesoptions, 'foo'));CHAR(13)+        assertequals(2, indexnames.size());CHAR(13)+        asserttrue(indexnames.contains('foo_foo'));CHAR(13)+        asserttrue(indexnames.contains('bar_bar'));CHAR(13)     }CHAR(13) CHAR(13)     public void testhiddenaliasandhiddenindexresolution() {CHAR(13)@@ -932,16 +1142,17 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         final string dottedhiddenalias = '.hidden_alias';CHAR(13)         final string dottedhiddenindex = '.hidden_index';CHAR(13) CHAR(13)-        indicesoptions excludehiddenoptions = indicesoptions.fromoptions(false, false, true, false, false, true, false, false, false);CHAR(13)-        indicesoptions includehiddenoptions = indicesoptions.fromoptions(false, false, true, false, true, true, false, false, false);CHAR(13)+        indicesoptions excludehiddenoptions = indicesoptions.fromoptions(false, true, true, false, false, true, false, false, false);CHAR(13)+        indicesoptions includehiddenoptions = indicesoptions.fromoptions(false, true, true, false, true, true, false, false, false);CHAR(13) CHAR(13)         {CHAR(13)             // a visible index with a visible alias and a hidden index with a hidden aliasCHAR(13)             metadata.builder mdbuilder = metadata.builder()CHAR(13)                 .put(indexbuilder(visibleindex).state(state.open).putalias(aliasmetadata.builder(visiblealias)))CHAR(13)-                .put(indexbuilder(hiddenindex,  settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                    .state(state.open)CHAR(13)-                    .putalias(aliasmetadata.builder(hiddenalias).ishidden(true)));CHAR(13)+                .put(CHAR(13)+                    indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                        .putalias(aliasmetadata.builder(hiddenalias).ishidden(true))CHAR(13)+                );CHAR(13)             clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)             // a total wildcard should only be resolved to visible indicesCHAR(13)@@ -981,9 +1192,10 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             // a visible alias that points to one hidden and one visible indexCHAR(13)             metadata.builder mdbuilder = metadata.builder()CHAR(13)                 .put(indexbuilder(visibleindex).state(state.open).putalias(aliasmetadata.builder(visiblealias)))CHAR(13)-                .put(indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                    .state(state.open)CHAR(13)-                    .putalias(aliasmetadata.builder(visiblealias)));CHAR(13)+                .put(CHAR(13)+                    indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                        .putalias(aliasmetadata.builder(visiblealias))CHAR(13)+                );CHAR(13)             clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)             // if the alias is resolved to concrete indices, it should resolve to all the indices it points to, hidden or not.CHAR(13)@@ -1006,9 +1218,10 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             // a hidden alias that points to one hidden and one visible indexCHAR(13)             metadata.builder mdbuilder = metadata.builder()CHAR(13)                 .put(indexbuilder(visibleindex).state(state.open).putalias(aliasmetadata.builder(hiddenalias).ishidden(true)))CHAR(13)-                .put(indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                    .state(state.open)CHAR(13)-                    .putalias(aliasmetadata.builder(hiddenalias).ishidden(true)));CHAR(13)+                .put(CHAR(13)+                    indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                        .putalias(aliasmetadata.builder(hiddenalias).ishidden(true))CHAR(13)+                );CHAR(13)             clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)             string[] indexnames;CHAR(13)@@ -1017,9 +1230,9 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             indexnames = indexnameexpressionresolver.concreteindexnames(state, includehiddenoptions, '*');CHAR(13)             assertthat(arrays.aslist(indexnames), containsinanyorder(visibleindex, hiddenindex));CHAR(13) CHAR(13)-            // a query that only matches the hidden alias should throwCHAR(13)-            expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(state, excludehiddenoptions, '*_alias'));CHAR(13)+            // a query that only matches the hidden resolves to no indicesCHAR(13)+            indexnames = indexnameexpressionresolver.concreteindexnames(state, excludehiddenoptions, '*_alias');CHAR(13)+            assertthat(arrays.aslist(indexnames), empty());CHAR(13) CHAR(13)             // but if we include hidden it should be resolved to both indicesCHAR(13)             indexnames = indexnameexpressionresolver.concreteindexnames(state, includehiddenoptions, '*_alias');CHAR(13)@@ -1035,12 +1248,14 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         {CHAR(13)             // a hidden alias with a dot-prefixed name that points to one hidden index with a dot prefix, and one hidden index withoutCHAR(13)             metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder(dottedhiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                    .state(state.open)CHAR(13)-                    .putalias(aliasmetadata.builder(dottedhiddenalias).ishidden(true)))CHAR(13)-                .put(indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                    .state(state.open)CHAR(13)-                    .putalias(aliasmetadata.builder(dottedhiddenalias).ishidden(true)));CHAR(13)+                .put(CHAR(13)+                    indexbuilder(dottedhiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                        .putalias(aliasmetadata.builder(dottedhiddenalias).ishidden(true))CHAR(13)+                )CHAR(13)+                .put(CHAR(13)+                    indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                        .putalias(aliasmetadata.builder(dottedhiddenalias).ishidden(true))CHAR(13)+                );CHAR(13)             clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)             string[] indexnames;CHAR(13)@@ -1050,14 +1265,13 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             indexnames = indexnameexpressionresolver.concreteindexnames(state, excludehiddenoptions, '.hidden_a*');CHAR(13)             assertthat(arrays.aslist(indexnames), containsinanyorder(dottedhiddenindex, hiddenindex));CHAR(13) CHAR(13)-            // a query that doesn't include the dot should fail if the options don't include hiddenCHAR(13)-            expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(state, excludehiddenoptions, '*_alias'));CHAR(13)+            // a query that doesn't include the dot resolves to no indicesCHAR(13)+            indexnames = indexnameexpressionresolver.concreteindexnames(state, excludehiddenoptions, '*_alias');CHAR(13)+            assertthat(arrays.aslist(indexnames), empty());CHAR(13) CHAR(13)             // but should include both indices if the options do include hiddenCHAR(13)             indexnames = indexnameexpressionresolver.concreteindexnames(state, includehiddenoptions, '*_alias');CHAR(13)             assertthat(arrays.aslist(indexnames), containsinanyorder(dottedhiddenindex, hiddenindex));CHAR(13)-CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)@@ -1070,10 +1284,11 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         indicesoptions includehiddenoptions = indicesoptions.fromoptions(false, true, true, false, true, true, false, false, false);CHAR(13) CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder(hiddenindex,  settings.builder().put(index_hidden_setting.getkey(), true).build())CHAR(13)-                .state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder(hiddenalias).ishidden(true))CHAR(13)-                .putalias(aliasmetadata.builder(visiblealias).build()));CHAR(13)+            .put(CHAR(13)+                indexbuilder(hiddenindex, settings.builder().put(index_hidden_setting.getkey(), true).build()).state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder(hiddenalias).ishidden(true))CHAR(13)+                    .putalias(aliasmetadata.builder(visiblealias).build())CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         string[] indexnames;CHAR(13)@@ -1093,27 +1308,26 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)      */CHAR(13)     public void testconcreteindicesallpatternrandom() {CHAR(13)         for (int i = 0; i < 10; i++) {CHAR(13)-            final string[] allindices;CHAR(13)-            switch (randomintbetween(0, 2)) {CHAR(13)-                case 0:CHAR(13)-                    allindices = null;CHAR(13)-                    break;CHAR(13)-                case 1:CHAR(13)-                    allindices = new string[0];CHAR(13)-                    break;CHAR(13)-                case 2:CHAR(13)-                    allindices = new string[] { metadata.all };CHAR(13)-                    break;CHAR(13)-                default:CHAR(13)-                    throw new unsupportedoperationexception();CHAR(13)-            }CHAR(13)-            final indicesoptions indicesoptions = indicesoptions.fromoptions(randomboolean(), randomboolean(),CHAR(13)-                    randomboolean(), randomboolean());CHAR(13)+            final string[] allindices = switch (randomintbetween(0, 2)) {CHAR(13)+                case 0 -> null;CHAR(13)+                case 1 -> new string[0];CHAR(13)+                case 2 -> new string[] { metadata.all };CHAR(13)+                default -> throw new unsupportedoperationexception();CHAR(13)+            };CHAR(13)+            final indicesoptions indicesoptions = indicesoptions.fromoptions(CHAR(13)+                randomboolean(),CHAR(13)+                randomboolean(),CHAR(13)+                randomboolean(),CHAR(13)+                randomboolean()CHAR(13)+            );CHAR(13) CHAR(13)             {CHAR(13)                 clusterstate state = clusterstate.builder(new clustername('_name')).metadata(metadata.builder().build()).build();CHAR(13)-                indexnameexpressionresolver.context context =CHAR(13)-                    new indexnameexpressionresolver.context(state, indicesoptions, systemindexaccesslevel.none);CHAR(13)+                indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                    state,CHAR(13)+                    indicesoptions,CHAR(13)+                    systemindexaccesslevel.noneCHAR(13)+                );CHAR(13) CHAR(13)                 // with no indices, asking for all indices should return empty list or exception, depending on indices optionsCHAR(13)                 if (indicesoptions.allownoindices()) {CHAR(13)@@ -1128,12 +1342,15 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             {CHAR(13)                 // with existing indices, asking for all indices should return all open/closed indices depending on optionsCHAR(13)                 metadata.builder mdbuilder = metadata.builder()CHAR(13)-                        .put(indexbuilder('aaa').state(state.open).putalias(aliasmetadata.builder('aaa_alias1')))CHAR(13)-                        .put(indexbuilder('bbb').state(state.open).putalias(aliasmetadata.builder('bbb_alias1')))CHAR(13)-                        .put(indexbuilder('ccc').state(state.close).putalias(aliasmetadata.builder('ccc_alias1')));CHAR(13)+                    .put(indexbuilder('aaa').state(state.open).putalias(aliasmetadata.builder('aaa_alias1')))CHAR(13)+                    .put(indexbuilder('bbb').state(state.open).putalias(aliasmetadata.builder('bbb_alias1')))CHAR(13)+                    .put(indexbuilder('ccc').state(state.close).putalias(aliasmetadata.builder('ccc_alias1')));CHAR(13)                 clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-                indexnameexpressionresolver.context context =CHAR(13)-                    new indexnameexpressionresolver.context(state, indicesoptions, systemindexaccesslevel.none);CHAR(13)+                indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                    state,CHAR(13)+                    indicesoptions,CHAR(13)+                    systemindexaccesslevel.noneCHAR(13)+                );CHAR(13)                 if (indicesoptions.expandwildcardsopen() || indicesoptions.expandwildcardsclosed() || indicesoptions.allownoindices()) {CHAR(13)                     string[] concreteindices = indexnameexpressionresolver.concreteindexnames(context, allindices);CHAR(13)                     assertthat(concreteindices, notnullvalue());CHAR(13)@@ -1159,20 +1376,24 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         for (int i = 0; i < 10; i++) {CHAR(13)             indicesoptions indicesoptions = indicesoptions.fromoptions(randomboolean(), randomboolean(), randomboolean(), randomboolean());CHAR(13)             metadata.builder mdbuilder = metadata.builder()CHAR(13)-                    .put(indexbuilder('aaa').state(state.open).putalias(aliasmetadata.builder('aaa_alias1')))CHAR(13)-                    .put(indexbuilder('bbb').state(state.open).putalias(aliasmetadata.builder('bbb_alias1')))CHAR(13)-                    .put(indexbuilder('ccc').state(state.close).putalias(aliasmetadata.builder('ccc_alias1')));CHAR(13)+                .put(indexbuilder('aaa').state(state.open).putalias(aliasmetadata.builder('aaa_alias1')))CHAR(13)+                .put(indexbuilder('bbb').state(state.open).putalias(aliasmetadata.builder('bbb_alias1')))CHAR(13)+                .put(indexbuilder('ccc').state(state.close).putalias(aliasmetadata.builder('ccc_alias1')));CHAR(13)             clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-            indexnameexpressionresolver.context context =CHAR(13)-                new indexnameexpressionresolver.context(state, indicesoptions, systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                indicesoptions,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13) CHAR(13)-            // asking for non existing wildcard pattern should return empty list or exceptionCHAR(13)-            if (indicesoptions.allownoindices()) {CHAR(13)+            if (indicesoptions.allownoindices() == falseCHAR(13)+                || indicesoptions.expandwildcardexpressions() == false && indicesoptions.ignoreunavailable() == false) {CHAR(13)+                expectthrows(indexnotfoundexception.class, () -> indexnameexpressionresolver.concreteindexnames(context, 'foo*'));CHAR(13)+            } else {CHAR(13)+                // asking for non existing wildcard pattern should return empty list or exceptionCHAR(13)                 string[] concreteindices = indexnameexpressionresolver.concreteindexnames(context, 'foo*');CHAR(13)                 assertthat(concreteindices, notnullvalue());CHAR(13)                 assertthat(concreteindices.length, equalto(0));CHAR(13)-            } else {CHAR(13)-                expectthrows(indexnotfoundexception.class, () -> indexnameexpressionresolver.concreteindexnames(context, 'foo*'));CHAR(13)             }CHAR(13)         }CHAR(13)     }CHAR(13)@@ -1225,81 +1446,36 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertthat(indexnameexpressionresolver.isexplicitallpattern(arrays.aslist('*')), equalto(false));CHAR(13)     }CHAR(13) CHAR(13)-    public void testispatternmatchingallindicesexplicitlist() throws exception {CHAR(13)-        //even though it does identify all indices, it's not a pattern but just an explicit list of themCHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(concreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, concreteindices, concreteindices), equalto(false));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesonlywildcard() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'*'};CHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(concreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(true));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesmatchingtrailingwildcard() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'index*'};CHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(concreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(true));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesnonmatchingtrailingwildcard() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'index*'};CHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        string[] allconcreteindices = new string[]{'index1', 'index2', 'index3', 'a', 'b'};CHAR(13)-        metadata metadata = metadatabuilder(allconcreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(false));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesmatchingsingleexclusion() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'-index1', 'index1'};CHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(concreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(true));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesnonmatchingsingleexclusion() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'-index1'};CHAR(13)-        string[] concreteindices = new string[]{'index2', 'index3'};CHAR(13)-        string[] allconcreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(allconcreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(false));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesmatchingtrailingwildcardandexclusion() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'index*', '-index1', 'index1'};CHAR(13)-        string[] concreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(concreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(true));CHAR(13)-    }CHAR(13)-CHAR(13)-    public void testispatternmatchingallindicesnonmatchingtrailingwildcardandexclusion() throws exception {CHAR(13)-        string[] indicesoraliases = new string[]{'index*', '-index1'};CHAR(13)-        string[] concreteindices = new string[]{'index2', 'index3'};CHAR(13)-        string[] allconcreteindices = new string[]{'index1', 'index2', 'index3'};CHAR(13)-        metadata metadata = metadatabuilder(allconcreteindices);CHAR(13)-        assertthat(indexnameexpressionresolver.ispatternmatchingallindices(metadata, indicesoraliases, concreteindices), equalto(false));CHAR(13)-    }CHAR(13)-CHAR(13)     public void testindexoptionsfailclosedindicesandaliases() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('foo1-closed').state(indexmetadata.state.close)CHAR(13)-                    .putalias(aliasmetadata.builder('foobar1-closed')).putalias(aliasmetadata.builder('foobar2-closed')))CHAR(13)-                .put(indexbuilder('foo2-closed').state(indexmetadata.state.close).putalias(aliasmetadata.builder('foobar2-closed')))CHAR(13)-                .put(indexbuilder('foo3').putalias(aliasmetadata.builder('foobar2-closed')));CHAR(13)+            .put(CHAR(13)+                indexbuilder('foo1-closed').state(indexmetadata.state.close)CHAR(13)+                    .putalias(aliasmetadata.builder('foobar1-closed'))CHAR(13)+                    .putalias(aliasmetadata.builder('foobar2-closed'))CHAR(13)+            )CHAR(13)+            .put(indexbuilder('foo2-closed').state(indexmetadata.state.close).putalias(aliasmetadata.builder('foobar2-closed')))CHAR(13)+            .put(indexbuilder('foo3').putalias(aliasmetadata.builder('foobar2-closed')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indexnameexpressionresolver.context contextice =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopenandforbidclosed(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context contextice = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.strictexpandopenandforbidclosed(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         expectthrows(indexclosedexception.class, () -> indexnameexpressionresolver.concreteindexnames(contextice, 'foo1-closed'));CHAR(13)         expectthrows(indexclosedexception.class, () -> indexnameexpressionresolver.concreteindexnames(contextice, 'foobar1-closed'));CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true,CHAR(13)-                contextice.getoptions().allownoindices(), contextice.getoptions().expandwildcardsopen(),CHAR(13)-            contextice.getoptions().expandwildcardsclosed(), contextice.getoptions()), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(CHAR(13)+                true,CHAR(13)+                contextice.getoptions().allownoindices(),CHAR(13)+                contextice.getoptions().expandwildcardsopen(),CHAR(13)+                contextice.getoptions().expandwildcardsclosed(),CHAR(13)+                contextice.getoptions()CHAR(13)+            ),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         string[] results = indexnameexpressionresolver.concreteindexnames(context, 'foo1-closed');CHAR(13)         assertthat(results, emptyarray());CHAR(13) CHAR(13)@@ -1316,8 +1492,11 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertthat(results, arraycontaining('foo1-closed'));CHAR(13) CHAR(13)         // testing an alias pointing to three indices:CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopenandforbidclosed(),CHAR(13)-            systemindexaccesslevel.none);CHAR(13)+        context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.strictexpandopenandforbidclosed(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         try {CHAR(13)             indexnameexpressionresolver.concreteindexnames(context, 'foobar2-closed');CHAR(13)             fail('foo2-closed should be closed, but it is open');CHAR(13)@@ -1325,9 +1504,17 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             // expectedCHAR(13)         }CHAR(13) CHAR(13)-        context = new indexnameexpressionresolver.context(state, indicesoptions.fromoptions(true,CHAR(13)-            context.getoptions().allownoindices(), context.getoptions().expandwildcardsopen(),CHAR(13)-            context.getoptions().expandwildcardsclosed(), context.getoptions()), systemindexaccesslevel.none);CHAR(13)+        context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.fromoptions(CHAR(13)+                true,CHAR(13)+                context.getoptions().allownoindices(),CHAR(13)+                context.getoptions().expandwildcardsopen(),CHAR(13)+                context.getoptions().expandwildcardsclosed(),CHAR(13)+                context.getoptions()CHAR(13)+            ),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         results = indexnameexpressionresolver.concreteindexnames(context, 'foobar2-closed');CHAR(13)         assertthat(results, arraywithsize(1));CHAR(13)         assertthat(results, arraycontaining('foo3'));CHAR(13)@@ -1339,16 +1526,21 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)     }CHAR(13) CHAR(13)     public void testdedupconcreteindices() {CHAR(13)-        metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('index1').putalias(aliasmetadata.builder('alias1')));CHAR(13)+        metadata.builder mdbuilder = metadata.builder().put(indexbuilder('index1').putalias(aliasmetadata.builder('alias1')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indicesoptions[] indicesoptions = new indicesoptions[]{ indicesoptions.strictexpandopen(), indicesoptions.strictexpand(),CHAR(13)-                indicesoptions.lenientexpandopen(), indicesoptions.strictexpandopenandforbidclosed()};CHAR(13)+        indicesoptions[] indicesoptions = new indicesoptions[] {CHAR(13)+            indicesoptions.strictexpandopen(),CHAR(13)+            indicesoptions.strictexpand(),CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            indicesoptions.strictexpandopenandforbidclosed() };CHAR(13)         for (indicesoptions options : indicesoptions) {CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state, options,CHAR(13)-                systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)             string[] results = indexnameexpressionresolver.concreteindexnames(context, 'index1', 'index1', 'alias1');CHAR(13)-            assertthat(results, equalto(new string[]{'index1'}));CHAR(13)+            assertthat(results, equalto(new string[] { 'index1' }));CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)@@ -1366,31 +1558,36 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .put(indexbuilder('test-1').state(indexmetadata.state.close).putalias(aliasmetadata.builder('alias-1')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13)         string[] strings = indexnameexpressionresolver.concreteindexnames(context, 'alias-*');CHAR(13)-        assertarrayequals(new string[] {'test-0'}, strings);CHAR(13)+        assertarrayequals(new string[] { 'test-0' }, strings);CHAR(13) CHAR(13)         context = new indexnameexpressionresolver.context(state, indicesoptions.strictexpandopen(), systemindexaccesslevel.none);CHAR(13)         strings = indexnameexpressionresolver.concreteindexnames(context, 'alias-*');CHAR(13) CHAR(13)-        assertarrayequals(new string[] {'test-0'}, strings);CHAR(13)+        assertarrayequals(new string[] { 'test-0' }, strings);CHAR(13)     }CHAR(13) CHAR(13)     public void testresolveexpressions() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('test-0').state(state.open).putalias(aliasmetadata.builder('alias-0').filter('{ \'term\': \'foo\'}')))CHAR(13)-                .put(indexbuilder('test-1').state(state.open).putalias(aliasmetadata.builder('alias-1')));CHAR(13)+            .put(indexbuilder('test-0').state(state.open).putalias(aliasmetadata.builder('alias-0').filter('{ \'term\': \'foo\'}')))CHAR(13)+            .put(indexbuilder('test-1').state(state.open).putalias(aliasmetadata.builder('alias-1')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)-        assertequals(new hashset<>(arrays.aslist('alias-0', 'alias-1')),CHAR(13)-                indexnameexpressionresolver.resolveexpressions(state, 'alias-*'));CHAR(13)-        assertequals(new hashset<>(arrays.aslist('test-0', 'alias-0', 'alias-1')),CHAR(13)-                indexnameexpressionresolver.resolveexpressions(state, 'test-0', 'alias-*'));CHAR(13)-        assertequals(new hashset<>(arrays.aslist('test-0', 'test-1', 'alias-0', 'alias-1')),CHAR(13)-                indexnameexpressionresolver.resolveexpressions(state, 'test-*', 'alias-*'));CHAR(13)-        assertequals(new hashset<>(arrays.aslist('test-1', 'alias-1')),CHAR(13)-                indexnameexpressionresolver.resolveexpressions(state, '*-1'));CHAR(13)+        assertequals(new hashset<>(arrays.aslist('alias-0', 'alias-1')), indexnameexpressionresolver.resolveexpressions(state, 'alias-*'));CHAR(13)+        assertequals(CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'alias-0', 'alias-1')),CHAR(13)+            indexnameexpressionresolver.resolveexpressions(state, 'test-0', 'alias-*')CHAR(13)+        );CHAR(13)+        assertequals(CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-1', 'alias-0', 'alias-1')),CHAR(13)+            indexnameexpressionresolver.resolveexpressions(state, 'test-*', 'alias-*')CHAR(13)+        );CHAR(13)+        assertequals(new hashset<>(arrays.aslist('test-1', 'alias-1')), indexnameexpressionresolver.resolveexpressions(state, '*-1'));CHAR(13)     }CHAR(13) CHAR(13)     public void testfilteringaliases() {CHAR(13)@@ -1401,7 +1598,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         set<string> resolvedexpressions = new hashset<>(arrays.aslist('alias-0', 'alias-1'));CHAR(13)         string[] strings = indexnameexpressionresolver.filteringaliases(state, 'test-0', resolvedexpressions);CHAR(13)-        assertarrayequals(new string[] {'alias-0'}, strings);CHAR(13)+        assertarrayequals(new string[] { 'alias-0' }, strings);CHAR(13) CHAR(13)         // concrete index supersedes filtering aliasCHAR(13)         resolvedexpressions = new hashset<>(arrays.aslist('test-0', 'alias-0', 'alias-1'));CHAR(13)@@ -1415,20 +1612,27 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)     public void testindexaliases() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias-0').filter('{ \'term\': \'foo\'}'))CHAR(13)-                .putalias(aliasmetadata.builder('test-alias-1').filter('{ \'term\': \'foo\'}'))CHAR(13)-                .putalias(aliasmetadata.builder('test-alias-non-filtering'))CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-0').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias-0').filter('{ \'term\': \'foo\'}'))CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias-1').filter('{ \'term\': \'foo\'}'))CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias-non-filtering'))CHAR(13)             );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'test-*');CHAR(13) CHAR(13)-        string[] strings = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, true, resolvedexpressions);CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, x -> true, true, resolvedexpressions);CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias-0', 'test-alias-1', 'test-alias-non-filtering'}, strings);CHAR(13)-CHAR(13)-        strings = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> x.alias().equals('test-alias-1'), true,CHAR(13)-                resolvedexpressions);CHAR(13)+        assertarrayequals(new string[] { 'test-alias-0', 'test-alias-1', 'test-alias-non-filtering' }, strings);CHAR(13)+CHAR(13)+        strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> x.alias().equals('test-alias-1'),CHAR(13)+            x -> false,CHAR(13)+            true,CHAR(13)+            resolvedexpressionsCHAR(13)+        );CHAR(13)         assertarrayequals(null, strings);CHAR(13)     }CHAR(13) CHAR(13)@@ -1440,8 +1644,8 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)             .put(backingindex1, false)CHAR(13)             .put(backingindex2, false)CHAR(13)-            .put(new datastream(datastreamname1, createtimestampfield('@timestamp'), list.of(backingindex1.getindex())))CHAR(13)-            .put(new datastream(datastreamname2, createtimestampfield('@timestamp'), list.of(backingindex2.getindex())));CHAR(13)+            .put(newinstance(datastreamname1, list.of(backingindex1.getindex())))CHAR(13)+            .put(newinstance(datastreamname2, list.of(backingindex2.getindex())));CHAR(13)         mdbuilder.put('logs_foo', datastreamname1, null, '{ \'term\': \'foo\'}');CHAR(13)         mdbuilder.put('logs', datastreamname1, null, '{ \'term\': \'logs\'}');CHAR(13)         mdbuilder.put('logs_bar', datastreamname1, null, null);CHAR(13)@@ -1452,57 +1656,122 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             // only resolve aliases with with that refer to datastreamname1CHAR(13)             set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'l*');CHAR(13)             string index = backingindex1.getindex().getname();CHAR(13)-            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, true, resolvedexpressions);CHAR(13)-            assertthat(result, arraycontaininginanyorder('logs_foo', 'logs'));CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, x -> true, true, resolvedexpressions);CHAR(13)+            assertthat(result, arraycontaininginanyorder('logs_foo', 'logs', 'logs_bar'));CHAR(13)         }CHAR(13)         {CHAR(13)             // only resolve aliases with with that refer to datastreamname2CHAR(13)             set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'l*');CHAR(13)             string index = backingindex2.getindex().getname();CHAR(13)-            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, true, resolvedexpressions);CHAR(13)-            assertthat(result, arraycontaininginanyorder('logs_baz'));CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, x -> true, true, resolvedexpressions);CHAR(13)+            assertthat(result, arraycontaininginanyorder('logs_baz', 'logs_baz2'));CHAR(13)         }CHAR(13)         {CHAR(13)             // null is returned, because skipping identity check and resolvedexpressions contains the backing index nameCHAR(13)             set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'l*');CHAR(13)             string index = backingindex2.getindex().getname();CHAR(13)-            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, false, resolvedexpressions);CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(state, index, x -> true, x -> true, false, resolvedexpressions);CHAR(13)+            assertthat(result, nullvalue());CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // null is returned, because the wildcard expands to a list of aliases containing an unfiltered alias for datastreamname1CHAR(13)+            set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'l*');CHAR(13)+            string index = backingindex1.getindex().getname();CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(CHAR(13)+                state,CHAR(13)+                index,CHAR(13)+                x -> true,CHAR(13)+                datastreamalias::filteringrequired,CHAR(13)+                true,CHAR(13)+                resolvedexpressionsCHAR(13)+            );CHAR(13)+            assertthat(result, nullvalue());CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // null is returned, because an unfiltered alias is targeting the same data streamCHAR(13)+            set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, 'logs_bar', 'logs');CHAR(13)+            string index = backingindex1.getindex().getname();CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(CHAR(13)+                state,CHAR(13)+                index,CHAR(13)+                x -> true,CHAR(13)+                datastreamalias::filteringrequired,CHAR(13)+                true,CHAR(13)+                resolvedexpressionsCHAR(13)+            );CHAR(13)+            assertthat(result, nullvalue());CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // the filtered alias is returned because although we target the data stream name, skipidentity is trueCHAR(13)+            set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, datastreamname1, 'logs');CHAR(13)+            string index = backingindex1.getindex().getname();CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(CHAR(13)+                state,CHAR(13)+                index,CHAR(13)+                x -> true,CHAR(13)+                datastreamalias::filteringrequired,CHAR(13)+                true,CHAR(13)+                resolvedexpressionsCHAR(13)+            );CHAR(13)+            assertthat(result, arraycontaininginanyorder('logs'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // null is returned because we target the data stream name and skipidentity is falseCHAR(13)+            set<string> resolvedexpressions = indexnameexpressionresolver.resolveexpressions(state, datastreamname1, 'logs');CHAR(13)+            string index = backingindex1.getindex().getname();CHAR(13)+            string[] result = indexnameexpressionresolver.indexaliases(CHAR(13)+                state,CHAR(13)+                index,CHAR(13)+                x -> true,CHAR(13)+                datastreamalias::filteringrequired,CHAR(13)+                false,CHAR(13)+                resolvedexpressionsCHAR(13)+            );CHAR(13)             assertthat(result, nullvalue());CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)     public void testindexaliasesskipidentity() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('test-0').state(state.open)CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-0').state(state.open)CHAR(13)                     .putalias(aliasmetadata.builder('test-alias'))CHAR(13)                     .putalias(aliasmetadata.builder('other-alias'))CHAR(13)-                );CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         set<string> resolvedexpressions = new hashset<>(arrays.aslist('test-0', 'test-alias'));CHAR(13)-        string[] aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, false, resolvedexpressions);CHAR(13)+        string[] aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, x -> true, false, resolvedexpressions);CHAR(13)         assertnull(aliases);CHAR(13)-        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, true, resolvedexpressions);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, aliases);CHAR(13)+        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, x -> true, true, resolvedexpressions);CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, aliases);CHAR(13) CHAR(13)         resolvedexpressions = collections.singleton('other-alias');CHAR(13)-        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, false, resolvedexpressions);CHAR(13)-        assertarrayequals(new string[] {'other-alias'}, aliases);CHAR(13)-        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, true, resolvedexpressions);CHAR(13)-        assertarrayequals(new string[] {'other-alias'}, aliases);CHAR(13)+        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, x -> true, false, resolvedexpressions);CHAR(13)+        assertarrayequals(new string[] { 'other-alias' }, aliases);CHAR(13)+        aliases = indexnameexpressionresolver.indexaliases(state, 'test-0', x -> true, x -> true, true, resolvedexpressions);CHAR(13)+        assertarrayequals(new string[] { 'other-alias' }, aliases);CHAR(13)     }CHAR(13) CHAR(13)     public void testconcretewriteindexsuccessful() {CHAR(13)         boolean testzerowriteindex = randomboolean();CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? true : null)));CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-0').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? true : null))CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        string[] strings = indexnameexpressionresolverCHAR(13)-            .indexaliases(state, 'test-0', x -> true, true, new hashset<>(arrays.aslist('test-0', 'test-alias')));CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> true,CHAR(13)+            x -> true,CHAR(13)+            true,CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-alias'))CHAR(13)+        );CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, strings);CHAR(13)-        indicesrequest request =  new indicesrequest()  {CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, strings);CHAR(13)+        indicesrequest request = new indicesrequest() {CHAR(13) CHAR(13)             @overrideCHAR(13)             public string[] indices() {CHAR(13)@@ -1514,27 +1783,29 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)                 return indicesoptions.strictsingleindexnoexpandforbidclosed();CHAR(13)             }CHAR(13) CHAR(13)-            @overrideCHAR(13)-            public boolean includedatastreams() {CHAR(13)-                return false;CHAR(13)-            }CHAR(13)         };CHAR(13)         index writeindex = indexnameexpressionresolver.concretewriteindex(state, request);CHAR(13)         assertthat(writeindex.getname(), equalto('test-0'));CHAR(13) CHAR(13)-        state = clusterstate.builder(state).metadata(metadata.builder(state.metadata())CHAR(13)-            .put(indexbuilder('test-1').putalias(aliasmetadata.builder('test-alias')CHAR(13)-                .writeindex(testzerowriteindex ? randomfrom(false, null) : true)))).build();CHAR(13)+        state = clusterstate.builder(state)CHAR(13)+            .metadata(CHAR(13)+                metadata.builder(state.metadata())CHAR(13)+                    .put(CHAR(13)+                        indexbuilder('test-1').putalias(CHAR(13)+                            aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? randomfrom(false, null) : true)CHAR(13)+                        )CHAR(13)+                    )CHAR(13)+            )CHAR(13)+            .build();CHAR(13)         writeindex = indexnameexpressionresolver.concretewriteindex(state, request);CHAR(13)         assertthat(writeindex.getname(), equalto(testzerowriteindex ? 'test-0' : 'test-1'));CHAR(13)     }CHAR(13) CHAR(13)     public void testconcretewriteindexwithinvalidindicesrequest() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias')));CHAR(13)+            .put(indexbuilder('test-0').state(state.open).putalias(aliasmetadata.builder('test-alias')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        function<string[], indicesrequest> requestgen = (indices) -> new indicesrequest()  {CHAR(13)+        function<string[], indicesrequest> requestgen = (indices) -> new indicesrequest() {CHAR(13) CHAR(13)             @overrideCHAR(13)             public string[] indices() {CHAR(13)@@ -1546,38 +1817,47 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)                 return indicesoptions.strictsingleindexnoexpandforbidclosed();CHAR(13)             }CHAR(13) CHAR(13)-            @overrideCHAR(13)-            public boolean includedatastreams() {CHAR(13)-                return false;CHAR(13)-            }CHAR(13)         };CHAR(13)-        illegalargumentexception exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concretewriteindex(state, requestgen.apply(null)));CHAR(13)+        illegalargumentexception exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concretewriteindex(state, requestgen.apply(null))CHAR(13)+        );CHAR(13)         assertthat(exception.getmessage(), equalto('indices request must specify a single index expression'));CHAR(13)-        exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concretewriteindex(state, requestgen.apply(new string[] {'too', 'many'})));CHAR(13)+        exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concretewriteindex(state, requestgen.apply(new string[] { 'too', 'many' }))CHAR(13)+        );CHAR(13)         assertthat(exception.getmessage(), equalto('indices request must specify a single index expression'));CHAR(13) CHAR(13)-CHAR(13)     }CHAR(13) CHAR(13)     public void testconcretewriteindexwithwildcardexpansion() {CHAR(13)         boolean testzerowriteindex = randomboolean();CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-1').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? true : null)))CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? randomfrom(false, null) : true)));CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-1').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? true : null))CHAR(13)+            )CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-0').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias').writeindex(testzerowriteindex ? randomfrom(false, null) : true))CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        string[] strings = indexnameexpressionresolverCHAR(13)-            .indexaliases(state, 'test-0', x -> true, true, new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias')));CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> true,CHAR(13)+            x -> true,CHAR(13)+            true,CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias'))CHAR(13)+        );CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, strings);CHAR(13)-        indicesrequest request =  new indicesrequest()  {CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, strings);CHAR(13)+        indicesrequest request = new indicesrequest() {CHAR(13) CHAR(13)             @overrideCHAR(13)             public string[] indices() {CHAR(13)-                return new string[] { 'test-*'};CHAR(13)+                return new string[] { 'test-*' };CHAR(13)             }CHAR(13) CHAR(13)             @overrideCHAR(13)@@ -1585,92 +1865,171 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)                 return indicesoptions.strictexpandopenandforbidclosed();CHAR(13)             }CHAR(13) CHAR(13)-            @overrideCHAR(13)-            public boolean includedatastreams() {CHAR(13)-                return false;CHAR(13)-            }CHAR(13)         };CHAR(13) CHAR(13)-        illegalargumentexception exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concretewriteindex(state, request));CHAR(13)-        assertthat(exception.getmessage(),CHAR(13)-            equalto('the index expression [test-*] and options provided did not point to a single write-index'));CHAR(13)+        illegalargumentexception exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concretewriteindex(state, request)CHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            exception.getmessage(),CHAR(13)+            equalto('the index expression [test-*] and options provided did not point to a single write-index')CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)     public void testconcretewriteindexwithnowriteindexwithsingleindex() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(false)));CHAR(13)+            .put(indexbuilder('test-0').state(state.open).putalias(aliasmetadata.builder('test-alias').writeindex(false)));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        string[] strings = indexnameexpressionresolverCHAR(13)-            .indexaliases(state, 'test-0', x -> true, true, new hashset<>(arrays.aslist('test-0', 'test-alias')));CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> true,CHAR(13)+            x -> true,CHAR(13)+            true,CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-alias'))CHAR(13)+        );CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, strings);CHAR(13)-        docwriterequest request = randomfrom(new indexrequest('test-alias'),CHAR(13)-            new updaterequest('test-alias', '_id'), new deleterequest('test-alias'));CHAR(13)-        illegalargumentexception exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concretewriteindex(state, request.indicesoptions(), request.indices()[0], false, false));CHAR(13)-        assertthat(exception.getmessage(), equalto('no write index is defined for alias [test-alias].' +CHAR(13)-                ' the write index may be explicitly disabled using is_write_index=false or the alias points to multiple' +CHAR(13)-                ' indices without one being designated as a write index'));CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, strings);CHAR(13)+        docwriterequest<?> request = randomfrom(CHAR(13)+            new indexrequest('test-alias'),CHAR(13)+            new updaterequest('test-alias', '_id'),CHAR(13)+            new deleterequest('test-alias')CHAR(13)+        );CHAR(13)+        illegalargumentexception exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concretewriteindex(state, request.indicesoptions(), request.indices()[0], false, false)CHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            exception.getmessage(),CHAR(13)+            equalto(CHAR(13)+                'no write index is defined for alias [test-alias].'CHAR(13)+                    + ' the write index may be explicitly disabled using is_write_index=false or the alias points to multiple'CHAR(13)+                    + ' indices without one being designated as a write index'CHAR(13)+            )CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)     public void testconcretewriteindexwithnowriteindexwithmultipleindices() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(false, null))))CHAR(13)-            .put(indexbuilder('test-1').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(false, null))));CHAR(13)+            .put(indexbuilder('test-0').state(state.open).putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(false, null))))CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-1').state(state.open).putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(false, null)))CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        string[] strings = indexnameexpressionresolverCHAR(13)-            .indexaliases(state, 'test-0', x -> true, true, new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias')));CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> true,CHAR(13)+            x -> true,CHAR(13)+            true,CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias'))CHAR(13)+        );CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, strings);CHAR(13)-        docwriterequest request = randomfrom(new indexrequest('test-alias'),CHAR(13)-            new updaterequest('test-alias', '_id'), new deleterequest('test-alias'));CHAR(13)-        illegalargumentexception exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concretewriteindex(state, request.indicesoptions(), request.indices()[0], false, false));CHAR(13)-        assertthat(exception.getmessage(), equalto('no write index is defined for alias [test-alias].' +CHAR(13)-            ' the write index may be explicitly disabled using is_write_index=false or the alias points to multiple' +CHAR(13)-            ' indices without one being designated as a write index'));CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, strings);CHAR(13)+        docwriterequest<?> request = randomfrom(CHAR(13)+            new indexrequest('test-alias'),CHAR(13)+            new updaterequest('test-alias', '_id'),CHAR(13)+            new deleterequest('test-alias')CHAR(13)+        );CHAR(13)+        illegalargumentexception exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concretewriteindex(state, request.indicesoptions(), request.indices()[0], false, false)CHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            exception.getmessage(),CHAR(13)+            equalto(CHAR(13)+                'no write index is defined for alias [test-alias].'CHAR(13)+                    + ' the write index may be explicitly disabled using is_write_index=false or the alias points to multiple'CHAR(13)+                    + ' indices without one being designated as a write index'CHAR(13)+            )CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)     public void testaliasresolutionnotallowingmultipleindices() {CHAR(13)         boolean test0writeindex = randomboolean();CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-0').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(test0writeindex, null))))CHAR(13)-            .put(indexbuilder('test-1').state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(test0writeindex == false, null))));CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-0').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(test0writeindex, null)))CHAR(13)+            )CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-1').state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias').writeindex(randomfrom(test0writeindex == false, null)))CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        string[] strings = indexnameexpressionresolverCHAR(13)-            .indexaliases(state, 'test-0', x -> true, true, new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias')));CHAR(13)+        string[] strings = indexnameexpressionresolver.indexaliases(CHAR(13)+            state,CHAR(13)+            'test-0',CHAR(13)+            x -> true,CHAR(13)+            x -> true,CHAR(13)+            true,CHAR(13)+            new hashset<>(arrays.aslist('test-0', 'test-1', 'test-alias'))CHAR(13)+        );CHAR(13)         arrays.sort(strings);CHAR(13)-        assertarrayequals(new string[] {'test-alias'}, strings);CHAR(13)-        illegalargumentexception exception = expectthrows(illegalargumentexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concreteindexnames(state, indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)-                'test-alias'));CHAR(13)+        assertarrayequals(new string[] { 'test-alias' }, strings);CHAR(13)+        illegalargumentexception exception = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(CHAR(13)+                state,CHAR(13)+                indicesoptions.strictsingleindexnoexpandforbidclosed(),CHAR(13)+                'test-alias'CHAR(13)+            )CHAR(13)+        );CHAR(13)         assertthat(exception.getmessage(), endswith(', can't execute a single index op'));CHAR(13)     }CHAR(13) CHAR(13)     public void testdeleteindexignoresaliases() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('test-index').state(state.open)CHAR(13)-                        .putalias(aliasmetadata.builder('test-alias')))CHAR(13)-                .put(indexbuilder('index').state(state.open)CHAR(13)-                        .putalias(aliasmetadata.builder('test-alias2')));CHAR(13)+            .put(indexbuilder('test-index').state(state.open).putalias(aliasmetadata.builder('test-alias')))CHAR(13)+            .put(indexbuilder('index').state(state.open).putalias(aliasmetadata.builder('test-alias2')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         {CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, new deleteindexrequest('does_not_exist')));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, new deleteindexrequest('does_not_exist'))CHAR(13)+            );CHAR(13)             assertequals('does_not_exist', infe.getindex().getname());CHAR(13)             assertequals('no such index [does_not_exist]', infe.getmessage());CHAR(13)         }CHAR(13)         {CHAR(13)-            illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, new deleteindexrequest('test-alias')));CHAR(13)-            assertequals('the provided expression [test-alias] matches an alias, ' +CHAR(13)-                    'specify the corresponding concrete indices instead.', iae.getmessage());CHAR(13)+            // same delete request but with request options that do not expand wildcardsCHAR(13)+            deleteindexrequest request = new deleteindexrequest('does_not_exist').indicesoptions(CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                    randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+                )CHAR(13)+            );CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, request)CHAR(13)+            );CHAR(13)+            assertequals('does_not_exist', infe.getindex().getname());CHAR(13)+            assertequals('no such index [does_not_exist]', infe.getmessage());CHAR(13)+        }CHAR(13)+        {CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, new deleteindexrequest('test-alias'))CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'the provided expression [test-alias] matches an alias, specify the corresponding concrete indices instead.',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same delete request but with request options that do not expand wildcardsCHAR(13)+            deleteindexrequest request = new deleteindexrequest('test-alias').indicesoptions(CHAR(13)+                indicesoptions.fromoptions(false, true, false, false, false, false, true, false)CHAR(13)+            );CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, request)CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'the provided expression [test-alias] matches an alias, specify the corresponding concrete indices instead.',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)         }CHAR(13)         {CHAR(13)             deleteindexrequest deleteindexrequest = new deleteindexrequest('test-alias');CHAR(13)@@ -1678,11 +2037,20 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             string[] indices = indexnameexpressionresolver.concreteindexnames(state, deleteindexrequest);CHAR(13)             assertequals(0, indices.length);CHAR(13)         }CHAR(13)+        {CHAR(13)+            // same request as above but with request options that do not expand wildcardsCHAR(13)+            deleteindexrequest deleteindexrequest = new deleteindexrequest('test-alias');CHAR(13)+            deleteindexrequest.indicesoptions(indicesoptions.fromoptions(true, true, false, false, false, false, true, false));CHAR(13)+            string[] indices = indexnameexpressionresolver.concreteindexnames(state, deleteindexrequest);CHAR(13)+            assertequals(0, indices.length);CHAR(13)+        }CHAR(13)         {CHAR(13)             deleteindexrequest deleteindexrequest = new deleteindexrequest('test-a*');CHAR(13)             deleteindexrequest.indicesoptions(indicesoptions.fromoptions(randomboolean(), false, true, true, false, false, true, false));CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, deleteindexrequest));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, deleteindexrequest)CHAR(13)+            );CHAR(13)             assertequals(infe.getindex().getname(), 'test-a*');CHAR(13)         }CHAR(13)         {CHAR(13)@@ -1694,6 +2062,16 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertequals(1, indices.length);CHAR(13)             assertequals('test-index', indices[0]);CHAR(13)         }CHAR(13)+        {CHAR(13)+            string[] indices = indexnameexpressionresolver.concreteindexnames(CHAR(13)+                state,CHAR(13)+                new deleteindexrequest('test-index').indicesoptions(CHAR(13)+                    indicesoptions.fromoptions(false, true, false, false, false, false, false, false)CHAR(13)+                )CHAR(13)+            );CHAR(13)+            assertequals(1, indices.length);CHAR(13)+            assertequals('test-index', indices[0]);CHAR(13)+        }CHAR(13)         {CHAR(13)             string[] indices = indexnameexpressionresolver.concreteindexnames(state, new deleteindexrequest('test-*'));CHAR(13)             assertequals(1, indices.length);CHAR(13)@@ -1703,22 +2081,26 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)     public void testindicesaliasesrequestignoresaliases() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-                .put(indexbuilder('test-index').state(state.open)CHAR(13)-                        .putalias(aliasmetadata.builder('test-alias')))CHAR(13)-                .put(indexbuilder('index').state(state.open)CHAR(13)-                        .putalias(aliasmetadata.builder('test-alias2')));CHAR(13)+            .put(indexbuilder('test-index').state(state.open).putalias(aliasmetadata.builder('test-alias')))CHAR(13)+            .put(indexbuilder('index').state(state.open).putalias(aliasmetadata.builder('test-alias2')));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add().index('test-alias');CHAR(13)-            illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)-            assertequals('the provided expression [test-alias] matches an alias, ' +CHAR(13)-                    'specify the corresponding concrete indices instead.', iae.getmessage());CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'the provided expression [test-alias] matches an alias, ' + 'specify the corresponding concrete indices instead.',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)         }CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add().index('test-a*');CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)             assertequals('test-a*', infe.getindex().getname());CHAR(13)         }CHAR(13)         {CHAR(13)@@ -1735,15 +2117,21 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         }CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.remove().index('test-alias');CHAR(13)-            illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)-            assertequals('the provided expression [test-alias] matches an alias, ' +CHAR(13)-                    'specify the corresponding concrete indices instead.', iae.getmessage());CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'the provided expression [test-alias] matches an alias, ' + 'specify the corresponding concrete indices instead.',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)         }CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.remove().index('test-a*');CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)             assertequals('test-a*', infe.getindex().getname());CHAR(13)         }CHAR(13)         {CHAR(13)@@ -1760,15 +2148,21 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         }CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.removeindex().index('test-alias');CHAR(13)-            illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)-            assertequals('the provided expression [test-alias] matches an alias, ' +CHAR(13)-                    'specify the corresponding concrete indices instead.', iae.getmessage());CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'the provided expression [test-alias] matches an alias, ' + 'specify the corresponding concrete indices instead.',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)         }CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.removeindex().index('test-a*');CHAR(13)-            indexnotfoundexception infe = expectthrows(indexnotfoundexception.class,CHAR(13)-                    () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions));CHAR(13)+            indexnotfoundexception infe = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(state, aliasactions)CHAR(13)+            );CHAR(13)             assertequals('test-a*', infe.getindex().getname());CHAR(13)         }CHAR(13)         {CHAR(13)@@ -1791,107 +2185,150 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)             .put(backingindex, false)CHAR(13)-            .put(new datastream(datastreamname, createtimestampfield('@timestamp'), list.of(backingindex.getindex())));CHAR(13)+            .put(newinstance(datastreamname, list.of(backingindex.getindex())));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add().index(datastreamname);CHAR(13)-            assertthat(indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)-                arraycontaining(backingindexequalto(datastreamname, 1)));CHAR(13)+            assertthat(CHAR(13)+                indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)+                arraycontaining(backingindexequalto(datastreamname, 1))CHAR(13)+            );CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)             indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add().index('my-data-*').alias('my-data');CHAR(13)-            assertthat(indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)-                arraycontaining(backingindexequalto(datastreamname, 1)));CHAR(13)+            assertthat(CHAR(13)+                indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)+                arraycontaining(backingindexequalto(datastreamname, 1))CHAR(13)+            );CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add().index(datastreamname)CHAR(13)+            indicesaliasesrequest.aliasactions aliasactions = indicesaliasesrequest.aliasactions.add()CHAR(13)+                .index(datastreamname)CHAR(13)                 .alias('my-data');CHAR(13)-            assertthat(indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)-                arraycontaining(backingindexequalto(datastreamname, 1)));CHAR(13)+            assertthat(CHAR(13)+                indexnameexpressionresolver.concreteindexnames(state, aliasactions),CHAR(13)+                arraycontaining(backingindexequalto(datastreamname, 1))CHAR(13)+            );CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)     public void testinvalidindex() {CHAR(13)         metadata.builder mdbuilder = metadata.builder().put(indexbuilder('test'));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)-        indexnameexpressionresolver.context context =CHAR(13)-            new indexnameexpressionresolver.context(state, indicesoptions.lenientexpandopen(), systemindexaccesslevel.none);CHAR(13)+        indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+            state,CHAR(13)+            indicesoptions.lenientexpandopen(),CHAR(13)+            systemindexaccesslevel.noneCHAR(13)+        );CHAR(13) CHAR(13)-        invalidindexnameexception iine = expectthrows(invalidindexnameexception.class,CHAR(13)-            () -> indexnameexpressionresolver.concreteindexnames(context, '_foo'));CHAR(13)+        invalidindexnameexception iine = expectthrows(CHAR(13)+            invalidindexnameexception.class,CHAR(13)+            () -> indexnameexpressionresolver.concreteindexnames(context, '_foo')CHAR(13)+        );CHAR(13)         assertequals('invalid index name [_foo], must not start with '_'.', iine.getmessage());CHAR(13)     }CHAR(13) CHAR(13)     public void testignorethrottled() {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('test-index', settings.builder().put('index.frozen', true).build())CHAR(13)-                .state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias')))CHAR(13)-            .put(indexbuilder('index', settings.builder().put(indexsettings.index_search_throttled.getkey(), true).build())CHAR(13)-                 .state(state.open)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias2')))CHAR(13)-            .put(indexbuilder('index-closed', settings.builder().put('index.frozen', true).build())CHAR(13)-                .state(state.close)CHAR(13)-                .putalias(aliasmetadata.builder('test-alias-closed')));CHAR(13)+            .put(CHAR(13)+                indexbuilder('test-index', settings.builder().put('index.frozen', true).build()).state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias'))CHAR(13)+            )CHAR(13)+            .put(CHAR(13)+                indexbuilder('index', settings.builder().put(indexsettings.index_search_throttled.getkey(), true).build()).state(state.open)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias2'))CHAR(13)+            )CHAR(13)+            .put(CHAR(13)+                indexbuilder('index-closed', settings.builder().put('index.frozen', true).build()).state(state.close)CHAR(13)+                    .putalias(aliasmetadata.builder('test-alias-closed'))CHAR(13)+            );CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled, '*');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled,CHAR(13)+                '*'CHAR(13)+            );CHAR(13)             assertequals(1, indices.length);CHAR(13)             assertequals('index', indices[0].getname());CHAR(13)         }CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                indicesoptions.strict_expand_open_forbid_closed, 'test-alias');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions.strict_expand_open_forbid_closed,CHAR(13)+                'test-alias'CHAR(13)+            );CHAR(13)             assertequals(1, indices.length);CHAR(13)             assertequals('test-index', indices[0].getname());CHAR(13)         }CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled, 'test-alias');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled,CHAR(13)+                'test-alias'CHAR(13)+            );CHAR(13)             assertequals(0, indices.length);CHAR(13)         }CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled, 'test-*');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled,CHAR(13)+                'test-*'CHAR(13)+            );CHAR(13)             assertequals(1, indices.length);CHAR(13)             assertequals('index', indices[0].getname());CHAR(13)         }CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled, 'ind*', 'test-index');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions.strict_expand_open_forbid_closed_ignore_throttled,CHAR(13)+                'ind*',CHAR(13)+                'test-index'CHAR(13)+            );CHAR(13)             assertequals(1, indices.length);CHAR(13)-            arrays.sort(indices, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(indices, index.compare_by_name);CHAR(13)             assertequals('index', indices[0].getname());CHAR(13)         }CHAR(13) CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices,CHAR(13)-                    indicesoptions.option.ignore_throttled),CHAR(13)-                    enumset.of(indicesoptions.wildcardstates.open)), 'ind*', 'test-index');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices, indicesoptions.option.ignore_throttled),CHAR(13)+                    enumset.of(indicesoptions.wildcardstates.open)CHAR(13)+                ),CHAR(13)+                'ind*',CHAR(13)+                'test-index'CHAR(13)+            );CHAR(13)             assertequals(1, indices.length);CHAR(13)-            arrays.sort(indices, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(indices, index.compare_by_name);CHAR(13)             assertequals('index', indices[0].getname());CHAR(13)         }CHAR(13)         {CHAR(13)-            index[] indices = indexnameexpressionresolver.concreteindices(state,CHAR(13)-                new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)-                    enumset.of(indicesoptions.wildcardstates.open, indicesoptions.wildcardstates.closed)), 'ind*', 'test-index');CHAR(13)+            index[] indices = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                    enumset.of(indicesoptions.wildcardstates.open, indicesoptions.wildcardstates.closed)CHAR(13)+                ),CHAR(13)+                'ind*',CHAR(13)+                'test-index'CHAR(13)+            );CHAR(13)             assertequals(3, indices.length);CHAR(13)-            arrays.sort(indices, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(indices, index.compare_by_name);CHAR(13)             assertequals('index', indices[0].getname());CHAR(13)             assertequals('index-closed', indices[1].getname());CHAR(13)             assertequals('test-index', indices[2].getname());CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)-    public void testfullwildcardsystemindexresolutionallowed() {CHAR(13)+    public void testfullwildcardsystemindexresolutionwithexpandhiddenallowed() {CHAR(13)         clusterstate state = systemindextestclusterstate();CHAR(13)         searchrequest request = new searchrequest(randomfrom('*', '_all'));CHAR(13)+        request.indicesoptions(indicesoptions.strictexpandhidden());CHAR(13) CHAR(13)         list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)         assertthat(indexnames, containsinanyorder('some-other-index', '.ml-stuff', '.ml-meta', '.watches'));CHAR(13)@@ -1921,15 +2358,30 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         assertthat(indexnames, containsinanyorder('.ml-meta'));CHAR(13)     }CHAR(13) CHAR(13)+    public void testfullwildcardsystemindicesarehidden() {CHAR(13)+        clusterstate state = systemindextestclusterstate();CHAR(13)+        searchrequest request = new searchrequest(randomfrom('*', '_all'));CHAR(13)+CHAR(13)+        list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)+        assertthat(indexnames, containsinanyorder('some-other-index'));CHAR(13)+    }CHAR(13)+CHAR(13)     public void testfullwildcardsystemindexresolutiondeprecated() {CHAR(13)         threadcontext.putheader(system_index_access_control_header_key, boolean.false.tostring());CHAR(13)         clusterstate state = systemindextestclusterstate();CHAR(13)         searchrequest request = new searchrequest(randomfrom('*', '_all'));CHAR(13)+        request.indicesoptions(indicesoptions.strictexpandhidden());CHAR(13) CHAR(13)         list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)         assertthat(indexnames, containsinanyorder('some-other-index', '.ml-stuff', '.ml-meta', '.watches'));CHAR(13)-        assertwarnings('this request accesses system indices: [.ml-meta, .ml-stuff, .watches], but in a future major version, ' +CHAR(13)-            'direct access to system indices will be prevented by default');CHAR(13)+        assertwarnings(CHAR(13)+            true,CHAR(13)+            new deprecationwarning(CHAR(13)+                level.warn,CHAR(13)+                'this request accesses system indices: [.ml-meta, .ml-stuff, .watches], 'CHAR(13)+                    + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+            )CHAR(13)+        );CHAR(13) CHAR(13)     }CHAR(13) CHAR(13)@@ -1940,20 +2392,31 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)         assertthat(indexnames, containsinanyorder('.ml-meta'));CHAR(13)-        assertwarnings('this request accesses system indices: [.ml-meta], but in a future major version, direct access ' +CHAR(13)-            'to system indices will be prevented by default');CHAR(13)-CHAR(13)+        assertwarnings(CHAR(13)+            true,CHAR(13)+            new deprecationwarning(CHAR(13)+                level.warn,CHAR(13)+                'this request accesses system indices: [.ml-meta], 'CHAR(13)+                    + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+            )CHAR(13)+        );CHAR(13)     }CHAR(13) CHAR(13)-    public void testwildcardsystemindexreslutionsinglematchdeprecated() {CHAR(13)+    public void testwildcardsystemindexresolutionsinglematchdeprecated() {CHAR(13)         threadcontext.putheader(system_index_access_control_header_key, boolean.false.tostring());CHAR(13)         clusterstate state = systemindextestclusterstate();CHAR(13)         searchrequest request = new searchrequest('.w*');CHAR(13) CHAR(13)         list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)         assertthat(indexnames, containsinanyorder('.watches'));CHAR(13)-        assertwarnings('this request accesses system indices: [.watches], but in a future major version, direct access ' +CHAR(13)-            'to system indices will be prevented by default');CHAR(13)+        assertwarnings(CHAR(13)+            true,CHAR(13)+            new deprecationwarning(CHAR(13)+                level.warn,CHAR(13)+                'this request accesses system indices: [.watches], 'CHAR(13)+                    + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+            )CHAR(13)+        );CHAR(13) CHAR(13)     }CHAR(13) CHAR(13)@@ -1964,37 +2427,49 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)         assertthat(indexnames, containsinanyorder('.ml-meta', '.ml-stuff'));CHAR(13)-        assertwarnings('this request accesses system indices: [.ml-meta, .ml-stuff], but in a future major version, direct access ' +CHAR(13)-            'to system indices will be prevented by default');CHAR(13)+        assertwarnings(CHAR(13)+            true,CHAR(13)+            new deprecationwarning(CHAR(13)+                level.warn,CHAR(13)+                'this request accesses system indices: [.ml-meta, .ml-stuff], 'CHAR(13)+                    + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+            )CHAR(13)+        );CHAR(13) CHAR(13)     }CHAR(13) CHAR(13)     public void testexternalsystemindexaccess() {CHAR(13)         final clusterstate prev = systemindextestclusterstate();CHAR(13)         clusterstate state = clusterstate.builder(prev)CHAR(13)-            .metadata(metadata.builder(prev.metadata())CHAR(13)-                .put(indexbuilder('.external-sys-idx', settings.empty).state(state.open).system(true)))CHAR(13)+            .metadata(CHAR(13)+                metadata.builder(prev.metadata()).put(indexbuilder('.external-sys-idx', settings.empty).state(state.open).system(true))CHAR(13)+            )CHAR(13)             .build();CHAR(13)         systemindices systemindices = new systemindices(CHAR(13)-            map.of(CHAR(13)-                'ml',CHAR(13)+            list.of(CHAR(13)                 new feature(CHAR(13)                     'ml',CHAR(13)                     'ml indices',CHAR(13)-                    list.of(new systemindexdescriptor('.ml-meta', 'ml meta'), new systemindexdescriptor('.ml-stuff', 'other ml'))CHAR(13)+                    list.of(CHAR(13)+                        systemindexdescriptorutils.createunmanaged('.ml-meta*', 'ml meta'),CHAR(13)+                        systemindexdescriptorutils.createunmanaged('.ml-stuff*', 'other ml')CHAR(13)+                    )CHAR(13)+                ),CHAR(13)+                new feature(CHAR(13)+                    'watcher',CHAR(13)+                    'watcher indices',CHAR(13)+                    list.of(systemindexdescriptorutils.createunmanaged('.watches*', 'watches index'))CHAR(13)                 ),CHAR(13)-                'watcher',CHAR(13)-                new feature('watcher', 'watcher indices', list.of(new systemindexdescriptor('.watches', 'watches index'))),CHAR(13)-                'stack-component',CHAR(13)-                new feature('stack-component',CHAR(13)+                new feature(CHAR(13)+                    'stack-component',CHAR(13)                     'stack component',CHAR(13)                     list.of(CHAR(13)-                        new systemindexdescriptor(CHAR(13)-                            '.external-sys-idx',CHAR(13)-                            'external',CHAR(13)-                            type.external_unmanaged,CHAR(13)-                            list.of('stack-component', 'other')CHAR(13)-                        )CHAR(13)+                        systemindexdescriptor.builder()CHAR(13)+                            .setindexpattern('.external-sys-idx*')CHAR(13)+                            .setdescription('external')CHAR(13)+                            .settype(type.external_unmanaged)CHAR(13)+                            .setallowedelasticproductorigins(list.of('stack-component', 'other'))CHAR(13)+                            .build()CHAR(13)                     )CHAR(13)                 )CHAR(13)             )CHAR(13)@@ -2008,8 +2483,14 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)                 list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)                 assertthat(indexnames, contains('.external-sys-idx'));CHAR(13)-                assertwarnings('this request accesses system indices: [.external-sys-idx], but in a future major version, direct access ' +CHAR(13)-                    'to system indices will be prevented by default');CHAR(13)+                assertwarnings(CHAR(13)+                    true,CHAR(13)+                    new deprecationwarning(CHAR(13)+                        level.warn,CHAR(13)+                        'this request accesses system indices: [.external-sys-idx], 'CHAR(13)+                            + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+                    )CHAR(13)+                );CHAR(13)             }CHAR(13)         }CHAR(13)         {CHAR(13)@@ -2019,8 +2500,14 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)                 list<string> indexnames = resolveconcreteindexnamelist(state, request);CHAR(13)                 assertthat(indexnames, contains('.external-sys-idx'));CHAR(13)-                assertwarnings('this request accesses system indices: [.external-sys-idx], but in a future major version, direct access ' +CHAR(13)-                    'to system indices will be prevented by default');CHAR(13)+                assertwarnings(CHAR(13)+                    true,CHAR(13)+                    new deprecationwarning(CHAR(13)+                        level.warn,CHAR(13)+                        'this request accesses system indices: [.external-sys-idx], 'CHAR(13)+                            + 'but in a future major version, direct access to system indices will be prevented by default'CHAR(13)+                    )CHAR(13)+                );CHAR(13)             }CHAR(13)         }CHAR(13)         // product origin = stack-componentCHAR(13)@@ -2080,7 +2567,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)             .put(index1, false)CHAR(13)             .put(index2, false)CHAR(13)-            .put(new datastream(datastreamname, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())));CHAR(13)+            .put(newinstance(datastreamname, list.of(index1.getindex(), index2.getindex())));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         {CHAR(13)@@ -2100,7 +2587,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)             .put(index1, false)CHAR(13)             .put(index2, false)CHAR(13)-            .put(new datastream(datastreamname, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())));CHAR(13)+            .put(newinstance(datastreamname, list.of(index1.getindex(), index2.getindex())));CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         {CHAR(13)@@ -2111,24 +2598,44 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastreamname, 2, epochmillis)));CHAR(13)         }CHAR(13)         {CHAR(13)-            // ignore data streamsCHAR(13)-            indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream'));CHAR(13)+            // ignore data streams,allow no indices and expand wildcardsCHAR(13)+            indicesoptions indicesoptions = randomfrom(CHAR(13)+                indicesoptions.strict_expand_open,CHAR(13)+                new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices), enumset.of(indicesoptions.wildcardstates.open))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream')CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)         }CHAR(13)         {CHAR(13)-            // ignore data streams and allow no indicesCHAR(13)-            indicesoptions indicesoptions = new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)-                enumset.of(indicesoptions.wildcardstates.open));CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream'));CHAR(13)+            // ignore data streams and do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream')CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)         }CHAR(13)         {CHAR(13)             // ignore data streams, allow no indices and ignore unavailableCHAR(13)-            indicesoptions indicesoptions = new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices,CHAR(13)-                indicesoptions.option.ignore_unavailable), enumset.of(indicesoptions.wildcardstates.open));CHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices, indicesoptions.option.ignore_unavailable),CHAR(13)+                enumset.of(indicesoptions.wildcardstates.open)CHAR(13)+            );CHAR(13)+            index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream');CHAR(13)+            assertthat(result.length, equalto(0));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // ignore data streams, allow no indices, ignore unavailable and do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices, indicesoptions.option.ignore_unavailable),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, false, 'my-data-stream');CHAR(13)             assertthat(result.length, equalto(0));CHAR(13)         }CHAR(13)@@ -2137,28 +2644,83 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             index result = indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, true);CHAR(13)             assertthat(result.getname(), equalto(datastream.getdefaultbackingindexname(datastreamname, 2, epochmillis)));CHAR(13)         }CHAR(13)+        {CHAR(13)+            // same as above but don't expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            index result = indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, true);CHAR(13)+            assertthat(result.getname(), equalto(datastream.getdefaultbackingindexname(datastreamname, 2, epochmillis)));CHAR(13)+        }CHAR(13)         {CHAR(13)             // ignore data streamsCHAR(13)-            indicesoptions indicesoptions = new indicesoptions(enumset.noneof(indicesoptions.option.class),CHAR(13)-                enumset.of(indicesoptions.wildcardstates.open));CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', true, false));CHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.noneof(indicesoptions.option.class),CHAR(13)+                enumset.of(indicesoptions.wildcardstates.open)CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', true, false)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but don't expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.noneof(indicesoptions.option.class),CHAR(13)+                enumset.noneof(indicesoptions.wildcardstates.class)CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', true, false)CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)         }CHAR(13)         {CHAR(13)             // ignore data streams and allow no indicesCHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false));CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but don't expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false)CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)         }CHAR(13)         {CHAR(13)             // ignore data streams, allow no indices and ignore unavailableCHAR(13)-            indicesoptions indicesoptions = new indicesoptions(enumset.of(indicesoptions.option.allow_no_indices,CHAR(13)-                indicesoptions.option.ignore_unavailable), enumset.of(indicesoptions.wildcardstates.open));CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false));CHAR(13)-            assertthat(e.getmessage(), equalto('no such index [null]'));CHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices, indicesoptions.option.ignore_unavailable),CHAR(13)+                enumset.of(indicesoptions.wildcardstates.open)CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but don't expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices, indicesoptions.option.ignore_unavailable),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concretewriteindex(state, indicesoptions, 'my-data-stream', false, false)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [my-data-stream]'));CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)@@ -2183,9 +2745,9 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .put(index4, false)CHAR(13)             .put(index5, false)CHAR(13)             .put(index6, false)CHAR(13)-            .put(new datastream(datastream1, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())))CHAR(13)-            .put(new datastream(datastream2, createtimestampfield('@timestamp'), list.of(index3.getindex(), index4.getindex())))CHAR(13)-            .put(new datastream(datastream3, createtimestampfield('@timestamp'), list.of(index5.getindex(), index6.getindex())));CHAR(13)+            .put(newinstance(datastream1, list.of(index1.getindex(), index2.getindex())))CHAR(13)+            .put(newinstance(datastream2, list.of(index3.getindex(), index4.getindex())))CHAR(13)+            .put(newinstance(datastream3, list.of(index5.getindex(), index6.getindex())));CHAR(13)         mdbuilder.put(datastreamalias1, datastream1, null, null);CHAR(13)         mdbuilder.put(datastreamalias1, datastream2, true, null);CHAR(13)         mdbuilder.put(datastreamalias2, datastream2, null, null);CHAR(13)@@ -2193,43 +2755,112 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13) CHAR(13)         {CHAR(13)-            indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)+            indicesoptions indicesoptions = randomfrom(CHAR(13)+                indicesoptions.strict_expand_open,CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                    randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+                )CHAR(13)+            );CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, datastreamalias1);CHAR(13)             assertthat(result, arraycontaininginanyorder(index1.getindex(), index2.getindex(), index3.getindex(), index4.getindex()));CHAR(13)         }CHAR(13)         {CHAR(13)-            indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)+            indicesoptions indicesoptions = randomfrom(CHAR(13)+                indicesoptions.strict_expand_open,CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                    randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+                )CHAR(13)+            );CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, datastreamalias2);CHAR(13)             assertthat(result, arraycontaininginanyorder(index3.getindex(), index4.getindex()));CHAR(13)         }CHAR(13)         {CHAR(13)-            indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)+            indicesoptions indicesoptions = randomfrom(CHAR(13)+                indicesoptions.strict_expand_open,CHAR(13)+                new indicesoptions(CHAR(13)+                    enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                    randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+                )CHAR(13)+            );CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, datastreamalias3);CHAR(13)             assertthat(result, arraycontaininginanyorder(index5.getindex(), index6.getindex()));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias1));CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias1)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [' + datastreamalias1 + ']'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias1)CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [' + datastreamalias1 + ']'));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias2));CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias2)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [' + datastreamalias2 + ']'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias2)CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [' + datastreamalias2 + ']'));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            exception e = expectthrows(indexnotfoundexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias3));CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias3)CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), equalto('no such index [' + datastreamalias3 + ']'));CHAR(13)+        }CHAR(13)+        {CHAR(13)+            // same as above but do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            exception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindices(state, indicesoptions, false, datastreamalias3)CHAR(13)+            );CHAR(13)             assertthat(e.getmessage(), equalto('no such index [' + datastreamalias3 + ']'));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, 'my-alias*');CHAR(13)-            assertthat(result, arraycontaininginanyorder(index1.getindex(), index2.getindex(), index3.getindex(), index4.getindex(),CHAR(13)-                index5.getindex(), index6.getindex()));CHAR(13)+            assertthat(CHAR(13)+                result,CHAR(13)+                arraycontaininginanyorder(CHAR(13)+                    index1.getindex(),CHAR(13)+                    index2.getindex(),CHAR(13)+                    index3.getindex(),CHAR(13)+                    index4.getindex(),CHAR(13)+                    index5.getindex(),CHAR(13)+                    index6.getindex()CHAR(13)+                )CHAR(13)+            );CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)@@ -2242,6 +2873,16 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             assertthat(result, notnullvalue());CHAR(13)             assertthat(result.getname(), backingindexequalto(datastream2, 2));CHAR(13)         }CHAR(13)+        {CHAR(13)+            // same as above but do not expand wildcardsCHAR(13)+            indicesoptions indicesoptions = new indicesoptions(CHAR(13)+                enumset.of(indicesoptions.option.allow_no_indices),CHAR(13)+                randomfrom(enumset.noneof(indicesoptions.wildcardstates.class), enumset.of(indicesoptions.wildcardstates.hidden))CHAR(13)+            );CHAR(13)+            index result = indexnameexpressionresolver.concretewriteindex(state, indicesoptions, datastreamalias1, false, true);CHAR(13)+            assertthat(result, notnullvalue());CHAR(13)+            assertthat(result.getname(), backingindexequalto(datastream2, 2));CHAR(13)+        }CHAR(13)     }CHAR(13) CHAR(13)     public void testdatastreamswithwildcardexpression() {CHAR(13)@@ -2256,35 +2897,40 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .put(index2, false)CHAR(13)             .put(index3, false)CHAR(13)             .put(index4, false)CHAR(13)-            .put(new datastream(datastream1, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())))CHAR(13)-            .put(new datastream(datastream2, createtimestampfield('@timestamp'), list.of(index3.getindex(), index4.getindex())));CHAR(13)+            .put(newinstance(datastream1, list.of(index1.getindex(), index2.getindex())))CHAR(13)+            .put(newinstance(datastream2, list.of(index3.getindex(), index4.getindex())));CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, 'logs-*');CHAR(13)-            arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(result, index.compare_by_name);CHAR(13)             assertthat(result.length, equalto(4));CHAR(13)             assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 1, epochmillis)));CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)             assertthat(result[2].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 1, epochmillis)));CHAR(13)-            assertthat(result[3].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));;CHAR(13)+            assertthat(result[3].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)-            index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true,CHAR(13)-                randomfrom(new string[]{'*'}, new string[]{'_all'}, new string[0]));CHAR(13)-            arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+            index[] result = indexnameexpressionresolver.concreteindices(CHAR(13)+                state,CHAR(13)+                indicesoptions,CHAR(13)+                true,CHAR(13)+                randomfrom(new string[] { '*' }, new string[] { '_all' }, new string[0])CHAR(13)+            );CHAR(13)+            arrays.sort(result, index.compare_by_name);CHAR(13)             assertthat(result.length, equalto(4));CHAR(13)             assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 1, epochmillis)));CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)             assertthat(result[2].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 1, epochmillis)));CHAR(13)-            assertthat(result[3].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));;CHAR(13)+            assertthat(result[3].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));CHAR(13)+            ;CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, 'logs-m*');CHAR(13)-            arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(result, index.compare_by_name);CHAR(13)             assertthat(result.length, equalto(2));CHAR(13)             assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 1, epochmillis)));CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)@@ -2308,21 +2954,21 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .put(index2, false)CHAR(13)             .put(index3, false)CHAR(13)             .put(index4, false)CHAR(13)-            .put(new datastream(datastream1, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())))CHAR(13)-            .put(new datastream(datastream2, createtimestampfield('@timestamp'), list.of(index3.getindex(), index4.getindex())));CHAR(13)+            .put(newinstance(datastream1, list.of(index1.getindex(), index2.getindex())))CHAR(13)+            .put(newinstance(datastream2, list.of(index3.getindex(), index4.getindex())));CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name')).metadata(mdbuilder).build();CHAR(13)         indicesoptions indicesoptions = indicesoptions.strict_expand_open;CHAR(13)         {CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, 'logs-*');CHAR(13)-            arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(result, index.compare_by_name);CHAR(13)             assertthat(result.length, equalto(2));CHAR(13)             assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));CHAR(13)         }CHAR(13)         {CHAR(13)             index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, '*');CHAR(13)-            arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+            arrays.sort(result, index.compare_by_name);CHAR(13)             assertthat(result.length, equalto(2));CHAR(13)             assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)             assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream2, 2, epochmillis)));CHAR(13)@@ -2341,16 +2987,18 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .build();CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name'))CHAR(13)-            .metadata(metadata.builder()CHAR(13)-                .put(index1, false)CHAR(13)-                .put(index2, false)CHAR(13)-                .put(justanindex, false)CHAR(13)-                .put(new datastream(datastream1, createtimestampfield('@timestamp'),CHAR(13)-                    list.of(index1.getindex(), index2.getindex())))).build();CHAR(13)+            .metadata(CHAR(13)+                metadata.builder()CHAR(13)+                    .put(index1, false)CHAR(13)+                    .put(index2, false)CHAR(13)+                    .put(justanindex, false)CHAR(13)+                    .put(newinstance(datastream1, list.of(index1.getindex(), index2.getindex())))CHAR(13)+            )CHAR(13)+            .build();CHAR(13) CHAR(13)         indicesoptions indicesoptions = indicesoptions.strictexpandopenandforbidclosedignorethrottled();CHAR(13)         index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions, true, 'logs-*');CHAR(13)-        arrays.sort(result, comparator.comparing(index::getname));CHAR(13)+        arrays.sort(result, index.compare_by_name);CHAR(13)         assertthat(result.length, equalto(3));CHAR(13)         assertthat(result[0].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 1, epochmillis)));CHAR(13)         assertthat(result[1].getname(), equalto(datastream.getdefaultbackingindexname(datastream1, 2, epochmillis)));CHAR(13)@@ -2368,15 +3016,29 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)             .build();CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name'))CHAR(13)-            .metadata(metadata.builder()CHAR(13)-                .put(index1, false)CHAR(13)-                .put(index2, false)CHAR(13)-                .put(justanindex, false)CHAR(13)-                .put(new datastream(datastream1, createtimestampfield('@timestamp'),CHAR(13)-                    list.of(index1.getindex(), index2.getindex()), 2, collections.emptymap(), true, false))).build();CHAR(13)+            .metadata(CHAR(13)+                metadata.builder()CHAR(13)+                    .put(index1, false)CHAR(13)+                    .put(index2, false)CHAR(13)+                    .put(justanindex, false)CHAR(13)+                    .put(CHAR(13)+                        new datastream(CHAR(13)+                            datastream1,CHAR(13)+                            list.of(index1.getindex(), index2.getindex()),CHAR(13)+                            2,CHAR(13)+                            collections.emptymap(),CHAR(13)+                            true,CHAR(13)+                            false,CHAR(13)+                            false,CHAR(13)+                            false,CHAR(13)+                            nullCHAR(13)+                        )CHAR(13)+                    )CHAR(13)+            )CHAR(13)+            .build();CHAR(13) CHAR(13)         index[] result = indexnameexpressionresolver.concreteindices(state, indicesoptions.strictexpandhidden(), true, 'logs-*');CHAR(13)-        assertthat(result, arraycontaininginanyorder(index1.getindex(), index2.getindex(), justanindex.getindex() ));CHAR(13)+        assertthat(result, arraycontaininginanyorder(index1.getindex(), index2.getindex(), justanindex.getindex()));CHAR(13) CHAR(13)         result = indexnameexpressionresolver.concreteindices(state, indicesoptions.strictexpandopen(), true, 'logs-*');CHAR(13)         assertthat(result, arraycontaining(justanindex.getindex()));CHAR(13)@@ -2398,14 +3060,16 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)         indexmetadata index4 = createbackingindex(datastream2, 2).build();CHAR(13) CHAR(13)         clusterstate state = clusterstate.builder(new clustername('_name'))CHAR(13)-            .metadata(metadata.builder()CHAR(13)-                .put(index1, false)CHAR(13)-                .put(index2, false)CHAR(13)-                .put(index3, false)CHAR(13)-                .put(index4, false)CHAR(13)-                .put(justanindex, false)CHAR(13)-                .put(new datastream(datastream1, createtimestampfield('@timestamp'), list.of(index1.getindex(), index2.getindex())))CHAR(13)-                .put(new datastream(datastream2, createtimestampfield('@timestamp'), list.of(index3.getindex(), index4.getindex()))))CHAR(13)+            .metadata(CHAR(13)+                metadata.builder()CHAR(13)+                    .put(index1, false)CHAR(13)+                    .put(index2, false)CHAR(13)+                    .put(index3, false)CHAR(13)+                    .put(index4, false)CHAR(13)+                    .put(justanindex, false)CHAR(13)+                    .put(newinstance(datastream1, list.of(index1.getindex(), index2.getindex())))CHAR(13)+                    .put(newinstance(datastream2, list.of(index3.getindex(), index4.getindex())))CHAR(13)+            )CHAR(13)             .build();CHAR(13) CHAR(13)         list<string> names = indexnameexpressionresolver.datastreamnames(state, indicesoptions.lenientexpand(), 'log*');CHAR(13)@@ -2435,7 +3099,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)     public void testmathexpressionsupport() {CHAR(13)         instant instant = localdate.of(2021, 01, 11).atstartofday().toinstant(zoneoffset.utc);CHAR(13)-        string resolved = this.indexnameexpressionresolver.resolvedatemathexpression('<a-name-{now/m{yyyy-mm}}>', instant.toepochmilli());CHAR(13)+        string resolved = indexnameexpressionresolver.resolvedatemathexpression('<a-name-{now/m{yyyy-mm}}>', instant.toepochmilli());CHAR(13) CHAR(13)         assertequals(resolved, 'a-name-2021-01');CHAR(13)     }CHAR(13)@@ -2444,7 +3108,7 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         instant instant = localdate.of(2020, 12, 2).atstartofday().toinstant(zoneoffset.utc);CHAR(13)         final string indexname = '<older-date-{now/m{yyyy-mm}}>';CHAR(13)-        string resolved = this.indexnameexpressionresolver.resolvedatemathexpression(indexname, instant.toepochmilli());CHAR(13)+        string resolved = indexnameexpressionresolver.resolvedatemathexpression(indexname, instant.toepochmilli());CHAR(13) CHAR(13)         assertequals(resolved, 'older-date-2020-12');CHAR(13)     }CHAR(13)@@ -2455,36 +3119,157 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13) CHAR(13)         {CHAR(13)             indicesoptions options = indicesoptions.fromoptions(false, randomboolean(), randomboolean(), randomboolean(), randomboolean());CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                options, systemindexaccesslevel.none);CHAR(13)-            illegalargumentexception iae = expectthrows(illegalargumentexception.class,CHAR(13)-                () -> indexnameexpressionresolver.concreteindexnames(context, 'cluster:index', 'local'));CHAR(13)-            assertequals('cross-cluster calls are not supported in this context but remote indices were requested: [cluster:index]',CHAR(13)-                iae.getmessage());CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)+            illegalargumentexception iae = expectthrows(CHAR(13)+                illegalargumentexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, 'cluster:index', 'local')CHAR(13)+            );CHAR(13)+            assertequals(CHAR(13)+                'cross-cluster calls are not supported in this context but remote indices were requested: [cluster:index]',CHAR(13)+                iae.getmessage()CHAR(13)+            );CHAR(13)+            // but datemath with colon doesn't trip cross-cluster checkCHAR(13)+            indexnotfoundexception e = expectthrows(CHAR(13)+                indexnotfoundexception.class,CHAR(13)+                () -> indexnameexpressionresolver.concreteindexnames(context, '<datemath-{2001-01-01-13||+1h/h{yyyy-mm-dd-hh|-07:00}}>')CHAR(13)+            );CHAR(13)+            assertthat(e.getmessage(), containsstring('no such index [datemath-2001-01-01-14'));CHAR(13)         }CHAR(13)         {CHAR(13)             indicesoptions options = indicesoptions.fromoptions(true, true, randomboolean(), randomboolean(), randomboolean());CHAR(13)-            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(state,CHAR(13)-                options, systemindexaccesslevel.none);CHAR(13)+            indexnameexpressionresolver.context context = new indexnameexpressionresolver.context(CHAR(13)+                state,CHAR(13)+                options,CHAR(13)+                systemindexaccesslevel.noneCHAR(13)+            );CHAR(13)             string[] indexnames = indexnameexpressionresolver.concreteindexnames(context, 'cluster:index', 'local');CHAR(13)             assertequals(0, indexnames.length);CHAR(13)         }CHAR(13)     }CHAR(13) CHAR(13)+    public void testresolvewriteindexabstraction() {CHAR(13)+        clusterstate state = datastreamtesthelper.getclusterstatewithdatastreams(CHAR(13)+            list.of(new tuple<>('logs-foobar', 1)),CHAR(13)+            list.of('my-index')CHAR(13)+        );CHAR(13)+        final clusterstate finalstate = clusterstate.builder(state)CHAR(13)+            .metadata(CHAR(13)+                metadata.builder(state.getmetadata())CHAR(13)+                    .put(indexmetadata.builder(state.getmetadata().index('my-index')).putalias(new aliasmetadata.builder('my-alias')))CHAR(13)+                    .build()CHAR(13)+            )CHAR(13)+            .build();CHAR(13)+        function<string, list<docwriterequest<?>>> docwriterequestsforname = (name) -> list.of(CHAR(13)+            new indexrequest(name).optype(docwriterequest.optype.index),CHAR(13)+            new indexrequest(name).optype(docwriterequest.optype.create),CHAR(13)+            new deleterequest(name),CHAR(13)+            new updaterequest(name, randomalphaoflength(8))CHAR(13)+        );CHAR(13)+        for (docwriterequest<?> request : docwriterequestsforname.apply('logs-foobar')) {CHAR(13)+            if (request.optype() == docwriterequest.optype.create) {CHAR(13)+                indexabstraction result = indexnameexpressionresolver.resolvewriteindexabstraction(finalstate, request);CHAR(13)+                assertthat(result.gettype(), equalto(indexabstraction.type.data_stream));CHAR(13)+                assertthat(result.getname(), equalto('logs-foobar'));CHAR(13)+            } else {CHAR(13)+                indexnotfoundexception infe = expectthrows(CHAR(13)+                    indexnotfoundexception.class,CHAR(13)+                    () -> indexnameexpressionresolver.resolvewriteindexabstraction(finalstate, request)CHAR(13)+                );CHAR(13)+                assertthat(infe.tostring(), containsstring('logs-foobar'));CHAR(13)+                assertthat(infe.getmetadatakeys().contains(indexnameexpressionresolver.excluded_data_streams_key), is(true));CHAR(13)+            }CHAR(13)+        }CHAR(13)+        for (docwriterequest<?> request : docwriterequestsforname.apply('my-index')) {CHAR(13)+            indexabstraction result = indexnameexpressionresolver.resolvewriteindexabstraction(finalstate, request);CHAR(13)+            assertthat(result.getname(), equalto('my-index'));CHAR(13)+            assertthat(result.gettype(), equalto(indexabstraction.type.concrete_index));CHAR(13)+        }CHAR(13)+        for (docwriterequest<?> request : docwriterequestsforname.apply('my-alias')) {CHAR(13)+            indexabstraction result = indexnameexpressionresolver.resolvewriteindexabstraction(finalstate, request);CHAR(13)+            assertthat(result.getname(), equalto('my-alias'));CHAR(13)+            assertthat(result.gettype(), equalto(indexabstraction.type.alias));CHAR(13)+        }CHAR(13)+    }CHAR(13)+CHAR(13)+    public void testresolvewriteindexabstractionnowriteindexforalias() {CHAR(13)+        clusterstate state1 = datastreamtesthelper.getclusterstatewithdatastreams(CHAR(13)+            list.of(new tuple<>('logs-foobar', 1)),CHAR(13)+            list.of('my-index', 'my-index2')CHAR(13)+        );CHAR(13)+        clusterstate state2 = clusterstate.builder(state1)CHAR(13)+            .metadata(CHAR(13)+                metadata.builder(state1.getmetadata())CHAR(13)+                    .put(indexmetadata.builder(state1.getmetadata().index('my-index')).putalias(new aliasmetadata.builder('my-alias')))CHAR(13)+                    .put(indexmetadata.builder(state1.getmetadata().index('my-index2')).putalias(new aliasmetadata.builder('my-alias')))CHAR(13)+                    .build()CHAR(13)+            )CHAR(13)+            .build();CHAR(13)+CHAR(13)+        docwriterequest<?> request = new indexrequest('my-alias');CHAR(13)+        var e = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.resolvewriteindexabstraction(state2, request)CHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            e.getmessage(),CHAR(13)+            equalto(CHAR(13)+                'no write index is defined for alias [my-alias]. the write index may be explicitly disabled using is_write_index=false'CHAR(13)+                    + ' or the alias points to multiple indices without one being designated as a write index'CHAR(13)+            )CHAR(13)+        );CHAR(13)+    }CHAR(13)+CHAR(13)+    public void testresolvewriteindexabstractionmissing() {CHAR(13)+        clusterstate state = datastreamtesthelper.getclusterstatewithdatastreams(CHAR(13)+            list.of(new tuple<>('logs-foobar', 1)),CHAR(13)+            list.of('my-index')CHAR(13)+        );CHAR(13)+        docwriterequest<?> request = new indexrequest('logs-my-index');CHAR(13)+        expectthrows(indexnotfoundexception.class, () -> indexnameexpressionresolver.resolvewriteindexabstraction(state, request));CHAR(13)+    }CHAR(13)+CHAR(13)+    public void testresolvewriteindexabstractionmultiplematches() {CHAR(13)+        clusterstate state = datastreamtesthelper.getclusterstatewithdatastreams(list.of(), list.of('logs-foo', 'logs-bar'));CHAR(13)+        docwriterequest<?> request = mock(docwriterequest.class);CHAR(13)+        when(request.index()).thenreturn('logs-*');CHAR(13)+        when(request.indicesoptions()).thenreturn(indicesoptions.lenientexpandopen());CHAR(13)+        when(request.optype()).thenreturn(docwriterequest.optype.index);CHAR(13)+        when(request.includedatastreams()).thenreturn(true);CHAR(13)+        var e = expectthrows(CHAR(13)+            illegalargumentexception.class,CHAR(13)+            () -> indexnameexpressionresolver.resolvewriteindexabstraction(state, request)CHAR(13)+        );CHAR(13)+        assertthat(CHAR(13)+            e.getmessage(),CHAR(13)+            equalto('unable to return a single target as the provided expression and options got resolved to multiple targets')CHAR(13)+        );CHAR(13)+    }CHAR(13)+CHAR(13)+    public static indexmetadata.builder indexbuilder(string index) {CHAR(13)+        return indexbuilder(index, settings.empty);CHAR(13)+    }CHAR(13)+CHAR(13)     private clusterstate systemindextestclusterstate() {CHAR(13)-        settings settings = settings.builder().build();CHAR(13)         metadata.builder mdbuilder = metadata.builder()CHAR(13)-            .put(indexbuilder('.ml-meta', settings).state(state.open).system(true))CHAR(13)-            .put(indexbuilder('.watches', settings).state(state.open).system(true))CHAR(13)-            .put(indexbuilder('.ml-stuff', settings).state(state.open).system(true))CHAR(13)+            .put(indexbuilder('.ml-meta', systemindexdescriptor.default_settings).state(state.open).system(true))CHAR(13)+            .put(indexbuilder('.watches', systemindexdescriptor.default_settings).state(state.open).system(true))CHAR(13)+            .put(indexbuilder('.ml-stuff', systemindexdescriptor.default_settings).state(state.open).system(true))CHAR(13)             .put(indexbuilder('some-other-index').state(state.open));CHAR(13)         systemindices systemindices = new systemindices(CHAR(13)-            map.of('ml',CHAR(13)-                new feature('ml', 'ml indices',CHAR(13)-                    list.of(new systemindexdescriptor('.ml-meta', 'ml meta'), new systemindexdescriptor('.ml-stuff', 'other ml'))CHAR(13)+            list.of(CHAR(13)+                new feature(CHAR(13)+                    'ml',CHAR(13)+                    'ml indices',CHAR(13)+                    list.of(CHAR(13)+                        systemindexdescriptorutils.createunmanaged('.ml-meta*', 'ml meta'),CHAR(13)+                        systemindexdescriptorutils.createunmanaged('.ml-stuff*', 'other ml')CHAR(13)+                    )CHAR(13)                 ),CHAR(13)-                'watcher',CHAR(13)-                new feature('watcher', 'watcher indices', list.of(new systemindexdescriptor('.watches', 'watches index')))CHAR(13)+                new feature('watcher', 'watcher indices', list.of(systemindexdescriptorutils.createunmanaged('.watches*', 'watches index')))CHAR(13)             )CHAR(13)         );CHAR(13)         indexnameexpressionresolver = new indexnameexpressionresolver(threadcontext, systemindices);CHAR(13)@@ -2492,9 +3277,11 @@ public class indexnameexpressionresolvertests extends estestcase {CHAR(13)     }CHAR(13) CHAR(13)     private list<string> resolveconcreteindexnamelist(clusterstate state, searchrequest request) {CHAR(13)-        return arraysCHAR(13)-            .stream(indexnameexpressionresolver.concreteindices(state, request))CHAR(13)-            .map(index::getname)CHAR(13)-            .collect(collectors.tolist());CHAR(13)+        return arrays.stream(indexnameexpressionresolver.concreteindices(state, request)).map(index::getname).tolist();CHAR(13)     }CHAR(13)+CHAR(13)+    private static indexmetadata.builder indexbuilder(string index, settings additionalsettings) {CHAR(13)+        return indexmetadata.builder(index).settings(indexsettings(version.current, 1, 0).put(additionalsettings));CHAR(13)+    }CHAR(13)+CHAR(13) }CHAR(13)","",1,0,0